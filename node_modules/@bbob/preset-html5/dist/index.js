(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.BbobPresetHTML5 = {}));
})(this, (function (exports) { 'use strict';

    /* eslint-disable indent */ const isTagNode$1 = (el)=>typeof el === 'object' && !!el.tag;
    function process(tags, tree, core, options) {
        tree.walk((node)=>isTagNode$1(node) && tags[node.tag] ? tags[node.tag](node, core, options) : node);
    }
    /**
     * Creates preset for @bbob/core
     * @param defTags {Object}
     * @param processor {Function} a processor function of tree
     * @returns {function(*=): function(*=, *=): void}
     */ function createPreset(defTags, processor = process) {
        const presetFactory = (opts = {})=>{
            presetFactory.options = Object.assign(presetFactory.options || {}, opts);
            const presetExecutor = (tree, core)=>processor(defTags, tree, core, presetFactory.options);
            presetExecutor.options = presetFactory.options;
            return presetExecutor;
        };
        presetFactory.extend = (callback)=>createPreset(callback(defTags, presetFactory.options), processor);
        return presetFactory;
    }

    const OPEN_BRAKET = '[';
    const CLOSE_BRAKET = ']';
    const SLASH = '/';

    const isTagNode = (el)=>typeof el === 'object' && !!el.tag;
    const isStringNode = (el)=>typeof el === 'string';
    const keysReduce = (obj, reduce, def)=>Object.keys(obj).reduce(reduce, def);
    const getNodeLength = (node)=>{
        if (isTagNode(node)) {
            return node.content.reduce((count, contentNode)=>count + getNodeLength(contentNode), 0);
        }
        if (isStringNode(node)) {
            return node.length;
        }
        return 0;
    };
    /**
     * Appends value to Tag Node
     * @param {TagNode} node
     * @param value
     */ const appendToNode = (node, value)=>{
        node.content.push(value);
    };
    /**
     * Replaces " to &qquot;
     * @param {String} value
     */ const escapeHTML = (value)=>value.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/g, '&#039;')// eslint-disable-next-line no-script-url
        .replace(/(javascript|data|vbscript):/gi, '$1%3A');
    /**
     * Acept name and value and return valid html5 attribute string
     * @param {String} name
     * @param {String} value
     * @return {string}
     */ const attrValue = (name, value)=>{
        const type = typeof value;
        const types = {
            boolean: ()=>value ? `${name}` : '',
            number: ()=>`${name}="${value}"`,
            string: ()=>`${name}="${escapeHTML(value)}"`,
            object: ()=>`${name}="${escapeHTML(JSON.stringify(value))}"`
        };
        return types[type] ? types[type]() : '';
    };
    /**
     * Transforms attrs to html params string
     * @param values
     */ const attrsToString = (values)=>{
        // To avoid some malformed attributes
        if (values == null) {
            return '';
        }
        return keysReduce(values, (arr, key)=>[
                ...arr,
                attrValue(key, values[key])
            ], [
            ''
        ]).join(' ');
    };
    /**
     * Gets value from
     * @example
     * getUniqAttr({ 'foo': true, 'bar': bar' }) => 'bar'
     * @param attrs
     * @returns {string}
     */ const getUniqAttr = (attrs)=>keysReduce(attrs, (res, key)=>attrs[key] === key ? attrs[key] : null, null);

    const getTagAttrs = (tag, params)=>{
        const uniqAattr = getUniqAttr(params);
        if (uniqAattr) {
            const tagAttr = attrValue(tag, uniqAattr);
            const attrs = {
                ...params
            };
            delete attrs[uniqAattr];
            const attrsStr = attrsToString(attrs);
            return `${tagAttr}${attrsStr}`;
        }
        return `${tag}${attrsToString(params)}`;
    };
    class TagNode {
        attr(name, value) {
            if (typeof value !== 'undefined') {
                this.attrs[name] = value;
            }
            return this.attrs[name];
        }
        append(value) {
            return appendToNode(this, value);
        }
        get length() {
            return getNodeLength(this);
        }
        toTagStart({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {
            const tagAttrs = getTagAttrs(this.tag, this.attrs);
            return `${openTag}${tagAttrs}${closeTag}`;
        }
        toTagEnd({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {
            return `${openTag}${SLASH}${this.tag}${closeTag}`;
        }
        toTagNode() {
            return new TagNode(this.tag.toLowerCase(), this.attrs, this.content);
        }
        toString({ openTag =OPEN_BRAKET , closeTag =CLOSE_BRAKET  } = {}) {
            const isEmpty = this.content.length === 0;
            const content = this.content.reduce((r, node)=>r + node.toString({
                    openTag,
                    closeTag
                }), '');
            const tagStart = this.toTagStart({
                openTag,
                closeTag
            });
            if (isEmpty) {
                return tagStart;
            }
            return `${tagStart}${content}${this.toTagEnd({
            openTag,
            closeTag
        })}`;
        }
        constructor(tag, attrs, content){
            this.tag = tag;
            this.attrs = attrs;
            this.content = Array.isArray(content) ? content : [
                content
            ];
        }
    }
    TagNode.create = (tag, attrs = {}, content = [])=>new TagNode(tag, attrs, content);
    TagNode.isOf = (node, type)=>node.tag === type;

    const isStartsWith = (node, type)=>node[0] === type;
    const styleMap = {
        color: (val)=>`color:${val};`,
        size: (val)=>`font-size:${val};`
    };
    const getStyleFromAttrs = (attrs)=>Object.keys(attrs).reduce((acc, key)=>styleMap[key] ? acc.concat(styleMap[key](attrs[key])) : acc, []).join(' ');
    const asListItems = (content)=>{
        let listIdx = 0;
        const listItems = [];
        const createItemNode = ()=>TagNode.create('li');
        const ensureListItem = (val)=>{
            listItems[listIdx] = listItems[listIdx] || val;
        };
        const addItem = (val)=>{
            if (listItems[listIdx] && listItems[listIdx].content) {
                listItems[listIdx].content = listItems[listIdx].content.concat(val);
            } else {
                listItems[listIdx] = listItems[listIdx].concat(val);
            }
        };
        content.forEach((el)=>{
            if (isStringNode(el) && isStartsWith(el, '*')) {
                if (listItems[listIdx]) {
                    listIdx++;
                }
                ensureListItem(createItemNode());
                addItem(el.substr(1));
            } else if (isTagNode(el) && TagNode.isOf(el, '*')) {
                if (listItems[listIdx]) {
                    listIdx++;
                }
                ensureListItem(createItemNode());
            } else if (!isTagNode(listItems[listIdx])) {
                listIdx++;
                ensureListItem(el);
            } else if (listItems[listIdx]) {
                addItem(el);
            } else {
                ensureListItem(el);
            }
        });
        return [].concat(listItems);
    };
    const renderUrl = (node, render)=>getUniqAttr(node.attrs) ? getUniqAttr(node.attrs) : render(node.content);
    const toNode = (tag, attrs, content)=>({
            tag,
            attrs,
            content
        });
    const toStyle = (style)=>({
            style
        });
    var defaultTags = {
        b: (node)=>toNode('span', toStyle('font-weight: bold;'), node.content),
        i: (node)=>toNode('span', toStyle('font-style: italic;'), node.content),
        u: (node)=>toNode('span', toStyle('text-decoration: underline;'), node.content),
        s: (node)=>toNode('span', toStyle('text-decoration: line-through;'), node.content),
        url: (node, { render  }, options)=>toNode('a', {
                href: renderUrl(node, render)
            }, node.content),
        img: (node, { render  })=>toNode('img', {
                src: render(node.content)
            }, null),
        quote: (node)=>toNode('blockquote', {}, [
                toNode('p', {}, node.content)
            ]),
        code: (node)=>toNode('pre', {}, node.content),
        style: (node)=>toNode('span', toStyle(getStyleFromAttrs(node.attrs)), node.content),
        list: (node)=>{
            const type = getUniqAttr(node.attrs);
            return toNode(type ? 'ol' : 'ul', type ? {
                type
            } : {}, asListItems(node.content));
        }
    };

    var index = createPreset(defaultTags);

    exports.default = index;

    Object.defineProperty(exports, '__esModule', { value: true });

}));
