// node_modules/@bbob/plugin-helper/es/char.js
var N = "\n";
var TAB = "	";
var EQ = "=";
var QUOTEMARK = '"';
var SPACE = " ";
var OPEN_BRAKET = "[";
var CLOSE_BRAKET = "]";
var SLASH = "/";
var BACKSLASH = "\\";

// node_modules/@bbob/plugin-helper/es/helpers.js
var isTagNode = (el) => typeof el === "object" && !!el.tag;
var isStringNode = (el) => typeof el === "string";
var keysReduce = (obj, reduce, def) => Object.keys(obj).reduce(reduce, def);
var getNodeLength = (node) => {
  if (isTagNode(node)) {
    return node.content.reduce((count, contentNode) => count + getNodeLength(contentNode), 0);
  }
  if (isStringNode(node)) {
    return node.length;
  }
  return 0;
};
var appendToNode = (node, value) => {
  node.content.push(value);
};
var escapeHTML = (value) => value.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;").replace(/(javascript|data|vbscript):/gi, "$1%3A");
var attrValue = (name, value) => {
  const type = typeof value;
  const types = {
    boolean: () => value ? `${name}` : "",
    number: () => `${name}="${value}"`,
    string: () => `${name}="${escapeHTML(value)}"`,
    object: () => `${name}="${escapeHTML(JSON.stringify(value))}"`
  };
  return types[type] ? types[type]() : "";
};
var attrsToString = (values) => {
  if (values == null) {
    return "";
  }
  return keysReduce(values, (arr, key) => [
    ...arr,
    attrValue(key, values[key])
  ], [
    ""
  ]).join(" ");
};
var getUniqAttr = (attrs) => keysReduce(attrs, (res, key) => attrs[key] === key ? attrs[key] : null, null);

// node_modules/@bbob/plugin-helper/es/TagNode.js
var getTagAttrs = (tag, params) => {
  const uniqAattr = getUniqAttr(params);
  if (uniqAattr) {
    const tagAttr = attrValue(tag, uniqAattr);
    const attrs = {
      ...params
    };
    delete attrs[uniqAattr];
    const attrsStr = attrsToString(attrs);
    return `${tagAttr}${attrsStr}`;
  }
  return `${tag}${attrsToString(params)}`;
};
var TagNode = class {
  attr(name, value) {
    if (typeof value !== "undefined") {
      this.attrs[name] = value;
    }
    return this.attrs[name];
  }
  append(value) {
    return appendToNode(this, value);
  }
  get length() {
    return getNodeLength(this);
  }
  toTagStart({ openTag = OPEN_BRAKET, closeTag = CLOSE_BRAKET } = {}) {
    const tagAttrs = getTagAttrs(this.tag, this.attrs);
    return `${openTag}${tagAttrs}${closeTag}`;
  }
  toTagEnd({ openTag = OPEN_BRAKET, closeTag = CLOSE_BRAKET } = {}) {
    return `${openTag}${SLASH}${this.tag}${closeTag}`;
  }
  toTagNode() {
    return new TagNode(this.tag.toLowerCase(), this.attrs, this.content);
  }
  toString({ openTag = OPEN_BRAKET, closeTag = CLOSE_BRAKET } = {}) {
    const isEmpty = this.content.length === 0;
    const content = this.content.reduce((r, node) => r + node.toString({
      openTag,
      closeTag
    }), "");
    const tagStart = this.toTagStart({
      openTag,
      closeTag
    });
    if (isEmpty) {
      return tagStart;
    }
    return `${tagStart}${content}${this.toTagEnd({
      openTag,
      closeTag
    })}`;
  }
  constructor(tag, attrs, content) {
    this.tag = tag;
    this.attrs = attrs;
    this.content = Array.isArray(content) ? content : [
      content
    ];
  }
};
TagNode.create = (tag, attrs = {}, content = []) => new TagNode(tag, attrs, content);
TagNode.isOf = (node, type) => node.tag === type;

export {
  N,
  TAB,
  EQ,
  QUOTEMARK,
  SPACE,
  OPEN_BRAKET,
  CLOSE_BRAKET,
  SLASH,
  BACKSLASH,
  isTagNode,
  isStringNode,
  attrsToString,
  getUniqAttr,
  TagNode
};
//# sourceMappingURL=chunk-BHFTSBAC.js.map
