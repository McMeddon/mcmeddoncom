{
  "version": 3,
  "sources": ["../../@bbob/parser/es/Token.js", "../../@bbob/parser/es/utils.js", "../../@bbob/parser/es/lexer.js", "../../@bbob/parser/es/parse.js", "../../@bbob/core/es/utils.js", "../../@bbob/core/es/index.js", "../../@bbob/html/es/index.js"],
  "sourcesContent": ["import { OPEN_BRAKET, CLOSE_BRAKET, SLASH } from '@bbob/plugin-helper';\r\n// type, value, line, row,\r\nconst TOKEN_TYPE_ID = 'type'; // 0;\r\nconst TOKEN_VALUE_ID = 'value'; // 1;\r\nconst TOKEN_COLUMN_ID = 'row'; // 2;\r\nconst TOKEN_LINE_ID = 'line'; // 3;\r\nconst TOKEN_TYPE_WORD = 1; // 'word';\r\nconst TOKEN_TYPE_TAG = 2; // 'tag';\r\nconst TOKEN_TYPE_ATTR_NAME = 3; // 'attr-name';\r\nconst TOKEN_TYPE_ATTR_VALUE = 4; // 'attr-value';\r\nconst TOKEN_TYPE_SPACE = 5; // 'space';\r\nconst TOKEN_TYPE_NEW_LINE = 6; // 'new-line';\r\n/**\r\n * @param {Token} token\r\n * @returns {string}\r\n */ const getTokenValue = (token)=>{\r\n    if (token && typeof token[TOKEN_VALUE_ID] !== 'undefined') {\r\n        return token[TOKEN_VALUE_ID];\r\n    }\r\n    return '';\r\n};\r\n/**\r\n * @param {Token}token\r\n * @returns {number}\r\n */ const getTokenLine = (token)=>token && token[TOKEN_LINE_ID] || 0;\r\nconst getTokenColumn = (token)=>token && token[TOKEN_COLUMN_ID] || 0;\r\n/**\r\n * @param {Token} token\r\n * @returns {boolean}\r\n */ const isTextToken = (token)=>{\r\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\r\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_SPACE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_NEW_LINE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_WORD;\r\n    }\r\n    return false;\r\n};\r\n/**\r\n * @param {Token} token\r\n * @returns {boolean}\r\n */ const isTagToken = (token)=>{\r\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\r\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_TAG;\r\n    }\r\n    return false;\r\n};\r\nconst isTagEnd = (token)=>getTokenValue(token).charCodeAt(0) === SLASH.charCodeAt(0);\r\nconst isTagStart = (token)=>!isTagEnd(token);\r\nconst isAttrNameToken = (token)=>{\r\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\r\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_NAME;\r\n    }\r\n    return false;\r\n};\r\n/**\r\n * @param {Token} token\r\n * @returns {boolean}\r\n */ const isAttrValueToken = (token)=>{\r\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\r\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_VALUE;\r\n    }\r\n    return false;\r\n};\r\nconst getTagName = (token)=>{\r\n    const value = getTokenValue(token);\r\n    return isTagEnd(token) ? value.slice(1) : value;\r\n};\r\nconst convertTagToText = (token)=>{\r\n    let text = OPEN_BRAKET;\r\n    text += getTokenValue(token);\r\n    text += CLOSE_BRAKET;\r\n    return text;\r\n};\r\nclass Token {\r\n    isEmpty() {\r\n        // eslint-disable-next-line no-restricted-globals\r\n        return isNaN(this[TOKEN_TYPE_ID]);\r\n    }\r\n    isText() {\r\n        return isTextToken(this);\r\n    }\r\n    isTag() {\r\n        return isTagToken(this);\r\n    }\r\n    isAttrName() {\r\n        return isAttrNameToken(this);\r\n    }\r\n    isAttrValue() {\r\n        return isAttrValueToken(this);\r\n    }\r\n    isStart() {\r\n        return isTagStart(this);\r\n    }\r\n    isEnd() {\r\n        return isTagEnd(this);\r\n    }\r\n    getName() {\r\n        return getTagName(this);\r\n    }\r\n    getValue() {\r\n        return getTokenValue(this);\r\n    }\r\n    getLine() {\r\n        return getTokenLine(this);\r\n    }\r\n    getColumn() {\r\n        return getTokenColumn(this);\r\n    }\r\n    toString() {\r\n        return convertTagToText(this);\r\n    }\r\n    /**\r\n   * @param {String} type\r\n   * @param {String} value\r\n   * @param line\r\n   * @param row\r\n   */ constructor(type, value, line, row){\r\n        this[TOKEN_TYPE_ID] = Number(type);\r\n        this[TOKEN_VALUE_ID] = String(value);\r\n        this[TOKEN_LINE_ID] = Number(line);\r\n        this[TOKEN_COLUMN_ID] = Number(row);\r\n    }\r\n}\r\nexport const TYPE_ID = TOKEN_TYPE_ID;\r\nexport const VALUE_ID = TOKEN_VALUE_ID;\r\nexport const LINE_ID = TOKEN_LINE_ID;\r\nexport const COLUMN_ID = TOKEN_COLUMN_ID;\r\nexport const TYPE_WORD = TOKEN_TYPE_WORD;\r\nexport const TYPE_TAG = TOKEN_TYPE_TAG;\r\nexport const TYPE_ATTR_NAME = TOKEN_TYPE_ATTR_NAME;\r\nexport const TYPE_ATTR_VALUE = TOKEN_TYPE_ATTR_VALUE;\r\nexport const TYPE_SPACE = TOKEN_TYPE_SPACE;\r\nexport const TYPE_NEW_LINE = TOKEN_TYPE_NEW_LINE;\r\nexport { Token };\r\nexport default Token;\r\n", "import { QUOTEMARK, BACKSLASH } from '@bbob/plugin-helper';\r\nfunction CharGrabber(source, options) {\r\n    const cursor = {\r\n        pos: 0,\r\n        len: source.length\r\n    };\r\n    const substrUntilChar = (char)=>{\r\n        const { pos  } = cursor;\r\n        const idx = source.indexOf(char, pos);\r\n        return idx >= 0 ? source.substring(pos, idx) : '';\r\n    };\r\n    const includes = (val)=>source.indexOf(val, cursor.pos) >= 0;\r\n    const hasNext = ()=>cursor.len > cursor.pos;\r\n    const isLast = ()=>cursor.pos === cursor.len;\r\n    const skip = (num = 1, silent)=>{\r\n        cursor.pos += num;\r\n        if (options && options.onSkip && !silent) {\r\n            options.onSkip();\r\n        }\r\n    };\r\n    const rest = ()=>source.substring(cursor.pos);\r\n    const grabN = (num = 0)=>source.substring(cursor.pos, cursor.pos + num);\r\n    const curr = ()=>source[cursor.pos];\r\n    const prev = ()=>{\r\n        const prevPos = cursor.pos - 1;\r\n        return typeof source[prevPos] !== 'undefined' ? source[prevPos] : null;\r\n    };\r\n    const next = ()=>{\r\n        const nextPos = cursor.pos + 1;\r\n        return nextPos <= source.length - 1 ? source[nextPos] : null;\r\n    };\r\n    const grabWhile = (cond, silent)=>{\r\n        let start = 0;\r\n        if (hasNext()) {\r\n            start = cursor.pos;\r\n            while(hasNext() && cond(curr())){\r\n                skip(1, silent);\r\n            }\r\n        }\r\n        return source.substring(start, cursor.pos);\r\n    };\r\n    /**\r\n   * @type {skip}\r\n   */ this.skip = skip;\r\n    /**\r\n   * @returns {Boolean}\r\n   */ this.hasNext = hasNext;\r\n    /**\r\n   * @returns {String}\r\n   */ this.getCurr = curr;\r\n    /**\r\n   * @returns {String}\r\n   */ this.getRest = rest;\r\n    /**\r\n   * @returns {String}\r\n   */ this.getNext = next;\r\n    /**\r\n   * @returns {String}\r\n   */ this.getPrev = prev;\r\n    /**\r\n   * @returns {Boolean}\r\n   */ this.isLast = isLast;\r\n    /**\r\n   * @returns {Boolean}\r\n   */ this.includes = includes;\r\n    /**\r\n   * @param {Function} cond\r\n   * @param {Boolean} silent\r\n   * @return {String}\r\n   */ this.grabWhile = grabWhile;\r\n    /**\r\n   * @param {Number} num\r\n   * @return {String}\r\n   */ this.grabN = grabN;\r\n    /**\r\n   * Grabs rest of string until it find a char\r\n   * @param {String} char\r\n   * @return {String}\r\n   */ this.substrUntilChar = substrUntilChar;\r\n}\r\n/**\r\n * Creates a grabber wrapper for source string, that helps to iterate over string char by char\r\n * @param {String} source\r\n * @param {Object} options\r\n * @param {Function} options.onSkip\r\n * @return CharGrabber\r\n */ export const createCharGrabber = (source, options)=>new CharGrabber(source, options);\r\n/**\r\n * Trims string from start and end by char\r\n * @example\r\n *  trimChar('*hello*', '*') ==> 'hello'\r\n * @param {String} str\r\n * @param {String} charToRemove\r\n * @returns {String}\r\n */ export const trimChar = (str, charToRemove)=>{\r\n    while(str.charAt(0) === charToRemove){\r\n        // eslint-disable-next-line no-param-reassign\r\n        str = str.substring(1);\r\n    }\r\n    while(str.charAt(str.length - 1) === charToRemove){\r\n        // eslint-disable-next-line no-param-reassign\r\n        str = str.substring(0, str.length - 1);\r\n    }\r\n    return str;\r\n};\r\n/**\r\n * Unquotes \\\" to \"\r\n * @param str\r\n * @return {String}\r\n */ export const unquote = (str)=>str.replace(BACKSLASH + QUOTEMARK, QUOTEMARK);\r\nfunction NodeList(values = []) {\r\n    const nodes = values;\r\n    const getLast = ()=>Array.isArray(nodes) && nodes.length > 0 && typeof nodes[nodes.length - 1] !== 'undefined' ? nodes[nodes.length - 1] : null;\r\n    const flushLast = ()=>nodes.length ? nodes.pop() : false;\r\n    const push = (value)=>nodes.push(value);\r\n    const toArray = ()=>nodes;\r\n    this.push = push;\r\n    this.toArray = toArray;\r\n    this.getLast = getLast;\r\n    this.flushLast = flushLast;\r\n}\r\n/**\r\n *\r\n * @param values\r\n * @return {NodeList}\r\n */ export const createList = (values = [])=>new NodeList(values);\r\n", "/* eslint-disable no-plusplus,no-param-reassign */ import { OPEN_BRAKET, CLOSE_BRAKET, QUOTEMARK, BACKSLASH, SLASH, SPACE, TAB, EQ, N } from '@bbob/plugin-helper';\r\nimport { Token, TYPE_ATTR_NAME, TYPE_ATTR_VALUE, TYPE_NEW_LINE, TYPE_SPACE, TYPE_TAG, TYPE_WORD } from './Token';\r\nimport { createCharGrabber, trimChar, unquote } from './utils';\r\n// for cases <!-- -->\r\nconst EM = '!';\r\n/**\r\n * Creates a Token entity class\r\n * @param {Number} type\r\n * @param {String} value\r\n * @param {Number} r line number\r\n * @param {Number} cl char number in line\r\n */ const createToken = (type, value, r = 0, cl = 0)=>new Token(type, value, r, cl);\r\n/**\r\n * @typedef {Object} Lexer\r\n * @property {Function} tokenize\r\n * @property {Function} isTokenNested\r\n */ /**\r\n * @param {String} buffer\r\n * @param {Object} options\r\n * @param {Function} options.onToken\r\n * @param {String} options.openTag\r\n * @param {String} options.closeTag\r\n * @param {Boolean} options.enableEscapeTags\r\n * @return {Lexer}\r\n */ function createLexer(buffer, options = {}) {\r\n    const STATE_WORD = 0;\r\n    const STATE_TAG = 1;\r\n    const STATE_TAG_ATTRS = 2;\r\n    const TAG_STATE_NAME = 0;\r\n    const TAG_STATE_ATTR = 1;\r\n    const TAG_STATE_VALUE = 2;\r\n    let row = 0;\r\n    let col = 0;\r\n    let tokenIndex = -1;\r\n    let stateMode = STATE_WORD;\r\n    let tagMode = TAG_STATE_NAME;\r\n    let contextFreeTag = '';\r\n    const tokens = new Array(Math.floor(buffer.length));\r\n    const openTag = options.openTag || OPEN_BRAKET;\r\n    const closeTag = options.closeTag || CLOSE_BRAKET;\r\n    const escapeTags = !!options.enableEscapeTags;\r\n    const contextFreeTags = options.contextFreeTags || [];\r\n    const onToken = options.onToken || (()=>{});\r\n    const RESERVED_CHARS = [\r\n        closeTag,\r\n        openTag,\r\n        QUOTEMARK,\r\n        BACKSLASH,\r\n        SPACE,\r\n        TAB,\r\n        EQ,\r\n        N,\r\n        EM\r\n    ];\r\n    const NOT_CHAR_TOKENS = [\r\n        openTag,\r\n        SPACE,\r\n        TAB,\r\n        N\r\n    ];\r\n    const WHITESPACES = [\r\n        SPACE,\r\n        TAB\r\n    ];\r\n    const SPECIAL_CHARS = [\r\n        EQ,\r\n        SPACE,\r\n        TAB\r\n    ];\r\n    const isCharReserved = (char)=>RESERVED_CHARS.indexOf(char) >= 0;\r\n    const isNewLine = (char)=>char === N;\r\n    const isWhiteSpace = (char)=>WHITESPACES.indexOf(char) >= 0;\r\n    const isCharToken = (char)=>NOT_CHAR_TOKENS.indexOf(char) === -1;\r\n    const isSpecialChar = (char)=>SPECIAL_CHARS.indexOf(char) >= 0;\r\n    const isEscapableChar = (char)=>char === openTag || char === closeTag || char === BACKSLASH;\r\n    const isEscapeChar = (char)=>char === BACKSLASH;\r\n    const onSkip = ()=>{\r\n        col++;\r\n    };\r\n    const unq = (val)=>unquote(trimChar(val, QUOTEMARK));\r\n    const checkContextFreeMode = (name, isClosingTag)=>{\r\n        if (contextFreeTag !== '' && isClosingTag) {\r\n            contextFreeTag = '';\r\n        }\r\n        if (contextFreeTag === '' && contextFreeTags.includes(name)) {\r\n            contextFreeTag = name;\r\n        }\r\n    };\r\n    const chars = createCharGrabber(buffer, {\r\n        onSkip\r\n    });\r\n    /**\r\n   * Emits newly created token to subscriber\r\n   * @param {Number} type\r\n   * @param {String} value\r\n   */ function emitToken(type, value) {\r\n        const token = createToken(type, value, row, col);\r\n        onToken(token);\r\n        tokenIndex += 1;\r\n        tokens[tokenIndex] = token;\r\n    }\r\n    function nextTagState(tagChars, isSingleValueTag) {\r\n        if (tagMode === TAG_STATE_ATTR) {\r\n            const validAttrName = (char)=>!(char === EQ || isWhiteSpace(char));\r\n            const name = tagChars.grabWhile(validAttrName);\r\n            const isEnd = tagChars.isLast();\r\n            const isValue = tagChars.getCurr() !== EQ;\r\n            tagChars.skip();\r\n            if (isEnd || isValue) {\r\n                emitToken(TYPE_ATTR_VALUE, unq(name));\r\n            } else {\r\n                emitToken(TYPE_ATTR_NAME, name);\r\n            }\r\n            if (isEnd) {\r\n                return TAG_STATE_NAME;\r\n            }\r\n            if (isValue) {\r\n                return TAG_STATE_ATTR;\r\n            }\r\n            return TAG_STATE_VALUE;\r\n        }\r\n        if (tagMode === TAG_STATE_VALUE) {\r\n            let stateSpecial = false;\r\n            const validAttrValue = (char)=>{\r\n                // const isEQ = char === EQ;\r\n                const isQM = char === QUOTEMARK;\r\n                const prevChar = tagChars.getPrev();\r\n                const nextChar = tagChars.getNext();\r\n                const isPrevSLASH = prevChar === BACKSLASH;\r\n                const isNextEQ = nextChar === EQ;\r\n                const isWS = isWhiteSpace(char);\r\n                // const isPrevWS = isWhiteSpace(prevChar);\r\n                const isNextWS = isWhiteSpace(nextChar);\r\n                if (stateSpecial && isSpecialChar(char)) {\r\n                    return true;\r\n                }\r\n                if (isQM && !isPrevSLASH) {\r\n                    stateSpecial = !stateSpecial;\r\n                    if (!stateSpecial && !(isNextEQ || isNextWS)) {\r\n                        return false;\r\n                    }\r\n                }\r\n                if (!isSingleValueTag) {\r\n                    return isWS === false;\r\n                // return (isEQ || isWS) === false;\r\n                }\r\n                return true;\r\n            };\r\n            const name1 = tagChars.grabWhile(validAttrValue);\r\n            tagChars.skip();\r\n            emitToken(TYPE_ATTR_VALUE, unq(name1));\r\n            if (tagChars.isLast()) {\r\n                return TAG_STATE_NAME;\r\n            }\r\n            return TAG_STATE_ATTR;\r\n        }\r\n        const validName = (char)=>!(char === EQ || isWhiteSpace(char) || tagChars.isLast());\r\n        const name2 = tagChars.grabWhile(validName);\r\n        emitToken(TYPE_TAG, name2);\r\n        checkContextFreeMode(name2);\r\n        tagChars.skip();\r\n        // in cases when we has [url=someval]GET[/url] and we dont need to parse all\r\n        if (isSingleValueTag) {\r\n            return TAG_STATE_VALUE;\r\n        }\r\n        const hasEQ = tagChars.includes(EQ);\r\n        return hasEQ ? TAG_STATE_ATTR : TAG_STATE_VALUE;\r\n    }\r\n    function stateTag() {\r\n        const currChar = chars.getCurr();\r\n        const nextChar = chars.getNext();\r\n        chars.skip();\r\n        // detect case where we have '[My word [tag][/tag]' or we have '[My last line word'\r\n        const substr = chars.substrUntilChar(closeTag);\r\n        const hasInvalidChars = substr.length === 0 || substr.indexOf(openTag) >= 0;\r\n        if (isCharReserved(nextChar) || hasInvalidChars || chars.isLast()) {\r\n            emitToken(TYPE_WORD, currChar);\r\n            return STATE_WORD;\r\n        }\r\n        // [myTag   ]\r\n        const isNoAttrsInTag = substr.indexOf(EQ) === -1;\r\n        // [/myTag]\r\n        const isClosingTag = substr[0] === SLASH;\r\n        if (isNoAttrsInTag || isClosingTag) {\r\n            const name = chars.grabWhile((char)=>char !== closeTag);\r\n            chars.skip(); // skip closeTag\r\n            emitToken(TYPE_TAG, name);\r\n            checkContextFreeMode(name, isClosingTag);\r\n            return STATE_WORD;\r\n        }\r\n        return STATE_TAG_ATTRS;\r\n    }\r\n    function stateAttrs() {\r\n        const silent = true;\r\n        const tagStr = chars.grabWhile((char)=>char !== closeTag, silent);\r\n        const tagGrabber = createCharGrabber(tagStr, {\r\n            onSkip\r\n        });\r\n        const hasSpace = tagGrabber.includes(SPACE);\r\n        tagMode = TAG_STATE_NAME;\r\n        while(tagGrabber.hasNext()){\r\n            tagMode = nextTagState(tagGrabber, !hasSpace);\r\n        }\r\n        chars.skip(); // skip closeTag\r\n        return STATE_WORD;\r\n    }\r\n    function stateWord() {\r\n        if (isNewLine(chars.getCurr())) {\r\n            emitToken(TYPE_NEW_LINE, chars.getCurr());\r\n            chars.skip();\r\n            col = 0;\r\n            row++;\r\n            return STATE_WORD;\r\n        }\r\n        if (isWhiteSpace(chars.getCurr())) {\r\n            const word = chars.grabWhile(isWhiteSpace);\r\n            emitToken(TYPE_SPACE, word);\r\n            return STATE_WORD;\r\n        }\r\n        if (chars.getCurr() === openTag) {\r\n            if (contextFreeTag) {\r\n                const fullTagLen = openTag.length + SLASH.length + contextFreeTag.length;\r\n                const fullTagName = `${openTag}${SLASH}${contextFreeTag}`;\r\n                const foundTag = chars.grabN(fullTagLen);\r\n                const isEndContextFreeMode = foundTag === fullTagName;\r\n                if (isEndContextFreeMode) {\r\n                    return STATE_TAG;\r\n                }\r\n            } else if (chars.includes(closeTag)) {\r\n                return STATE_TAG;\r\n            }\r\n            emitToken(TYPE_WORD, chars.getCurr());\r\n            chars.skip();\r\n            return STATE_WORD;\r\n        }\r\n        if (escapeTags) {\r\n            if (isEscapeChar(chars.getCurr())) {\r\n                const currChar = chars.getCurr();\r\n                const nextChar = chars.getNext();\r\n                chars.skip(); // skip the \\ without emitting anything\r\n                if (isEscapableChar(nextChar)) {\r\n                    chars.skip(); // skip past the [, ] or \\ as well\r\n                    emitToken(TYPE_WORD, nextChar);\r\n                    return STATE_WORD;\r\n                }\r\n                emitToken(TYPE_WORD, currChar);\r\n                return STATE_WORD;\r\n            }\r\n            const isChar = (char)=>isCharToken(char) && !isEscapeChar(char);\r\n            const word1 = chars.grabWhile(isChar);\r\n            emitToken(TYPE_WORD, word1);\r\n            return STATE_WORD;\r\n        }\r\n        const word2 = chars.grabWhile(isCharToken);\r\n        emitToken(TYPE_WORD, word2);\r\n        return STATE_WORD;\r\n    }\r\n    function tokenize() {\r\n        stateMode = STATE_WORD;\r\n        while(chars.hasNext()){\r\n            switch(stateMode){\r\n                case STATE_TAG:\r\n                    stateMode = stateTag();\r\n                    break;\r\n                case STATE_TAG_ATTRS:\r\n                    stateMode = stateAttrs();\r\n                    break;\r\n                case STATE_WORD:\r\n                default:\r\n                    stateMode = stateWord();\r\n                    break;\r\n            }\r\n        }\r\n        tokens.length = tokenIndex + 1;\r\n        return tokens;\r\n    }\r\n    function isTokenNested(token) {\r\n        const value = openTag + SLASH + token.getValue();\r\n        // potential bottleneck\r\n        return buffer.indexOf(value) > -1;\r\n    }\r\n    return {\r\n        tokenize,\r\n        isTokenNested\r\n    };\r\n}\r\nexport const createTokenOfType = createToken;\r\nexport { createLexer };\r\n", "import { TagNode, CLOSE_BRAKET, OPEN_BRAKET, isTagNode } from '@bbob/plugin-helper';\r\nimport { createLexer } from './lexer';\r\nimport { createList } from './utils';\r\n/**\r\n * @public\r\n * @param {String} input\r\n * @param {Object} opts\r\n * @param {Function} opts.createTokenizer\r\n * @param {Array<string>} opts.onlyAllowTags\r\n * @param {Array<string>} opts.contextFreeTags\r\n * @param {Boolean} opts.enableEscapeTags\r\n * @param {String} opts.openTag\r\n * @param {String} opts.closeTag\r\n * @return {Array}\r\n */ const parse = (input, opts = {})=>{\r\n    const options = opts;\r\n    const openTag = options.openTag || OPEN_BRAKET;\r\n    const closeTag = options.closeTag || CLOSE_BRAKET;\r\n    let tokenizer = null;\r\n    /**\r\n   * Result AST of nodes\r\n   * @private\r\n   * @type {NodeList}\r\n   */ const nodes = createList();\r\n    /**\r\n   * Temp buffer of nodes that's nested to another node\r\n   * @private\r\n   * @type {NodeList}\r\n   */ const nestedNodes = createList();\r\n    /**\r\n   * Temp buffer of nodes [tag..]...[/tag]\r\n   * @private\r\n   * @type {NodeList}\r\n   */ const tagNodes = createList();\r\n    /**\r\n   * Temp buffer of tag attributes\r\n   * @private\r\n   * @type {NodeList}\r\n   */ const tagNodesAttrName = createList();\r\n    /**\r\n   * Cache for nested tags checks\r\n   */ const nestedTagsMap = new Set();\r\n    /**\r\n   *\r\n   * @param token\r\n   * @returns {boolean}\r\n   */ const isTokenNested = (token)=>{\r\n        const value = token.getValue();\r\n        if (!nestedTagsMap.has(value) && tokenizer.isTokenNested && tokenizer.isTokenNested(token)) {\r\n            nestedTagsMap.add(value);\r\n            return true;\r\n        }\r\n        return nestedTagsMap.has(value);\r\n    };\r\n    /**\r\n   * @param tagName\r\n   * @returns {boolean}\r\n   */ const isTagNested = (tagName)=>Boolean(nestedTagsMap.has(tagName));\r\n    /**\r\n   * @private\r\n   * @param {String} value\r\n   * @return {boolean}\r\n   */ const isAllowedTag = (value)=>{\r\n        if (options.onlyAllowTags && options.onlyAllowTags.length) {\r\n            return options.onlyAllowTags.indexOf(value) >= 0;\r\n        }\r\n        return true;\r\n    };\r\n    /**\r\n   * Flushes temp tag nodes and its attributes buffers\r\n   * @private\r\n   * @return {Array}\r\n   */ const flushTagNodes = ()=>{\r\n        if (tagNodes.flushLast()) {\r\n            tagNodesAttrName.flushLast();\r\n        }\r\n    };\r\n    /**\r\n   * @private\r\n   * @return {Array}\r\n   */ const getNodes = ()=>{\r\n        const lastNestedNode = nestedNodes.getLast();\r\n        if (lastNestedNode && Array.isArray(lastNestedNode.content)) {\r\n            return lastNestedNode.content;\r\n        }\r\n        return nodes.toArray();\r\n    };\r\n    /**\r\n   * @private\r\n   * @param {string|TagNode} node\r\n   */ const appendNodes = (node)=>{\r\n        const items = getNodes();\r\n        if (Array.isArray(items)) {\r\n            if (isTagNode(node)) {\r\n                if (isAllowedTag(node.tag)) {\r\n                    items.push(node.toTagNode());\r\n                } else {\r\n                    items.push(node.toTagStart({\r\n                        openTag,\r\n                        closeTag\r\n                    }));\r\n                    if (node.content.length) {\r\n                        node.content.forEach((item)=>{\r\n                            items.push(item);\r\n                        });\r\n                        items.push(node.toTagEnd({\r\n                            openTag,\r\n                            closeTag\r\n                        }));\r\n                    }\r\n                }\r\n            } else {\r\n                items.push(node);\r\n            }\r\n        }\r\n    };\r\n    /**\r\n   * @private\r\n   * @param {Token} token\r\n   */ const handleTagStart = (token)=>{\r\n        flushTagNodes();\r\n        const tagNode = TagNode.create(token.getValue());\r\n        const isNested = isTokenNested(token);\r\n        tagNodes.push(tagNode);\r\n        if (isNested) {\r\n            nestedNodes.push(tagNode);\r\n        } else {\r\n            appendNodes(tagNode, token);\r\n        }\r\n    };\r\n    /**\r\n   * @private\r\n   * @param {Token} token\r\n   */ const handleTagEnd = (token)=>{\r\n        flushTagNodes();\r\n        const lastNestedNode = nestedNodes.flushLast();\r\n        if (lastNestedNode) {\r\n            appendNodes(lastNestedNode, token);\r\n        } else if (typeof options.onError === 'function') {\r\n            const tag = token.getValue();\r\n            const line = token.getLine();\r\n            const column = token.getColumn();\r\n            options.onError({\r\n                message: `Inconsistent tag '${tag}' on line ${line} and column ${column}`,\r\n                tagName: tag,\r\n                lineNumber: line,\r\n                columnNumber: column\r\n            });\r\n        }\r\n    };\r\n    /**\r\n   * @private\r\n   * @param {Token} token\r\n   */ const handleTag = (token)=>{\r\n        // [tag]\r\n        if (token.isStart()) {\r\n            handleTagStart(token);\r\n        }\r\n        // [/tag]\r\n        if (token.isEnd()) {\r\n            handleTagEnd(token);\r\n        }\r\n    };\r\n    /**\r\n   * @private\r\n   * @param {Token} token\r\n   */ const handleNode = (token)=>{\r\n        /**\r\n     * @type {TagNode}\r\n     */ const lastTagNode = tagNodes.getLast();\r\n        const tokenValue = token.getValue();\r\n        const isNested = isTagNested(token);\r\n        if (lastTagNode) {\r\n            if (token.isAttrName()) {\r\n                tagNodesAttrName.push(tokenValue);\r\n                lastTagNode.attr(tagNodesAttrName.getLast(), '');\r\n            } else if (token.isAttrValue()) {\r\n                const attrName = tagNodesAttrName.getLast();\r\n                if (attrName) {\r\n                    lastTagNode.attr(attrName, tokenValue);\r\n                    tagNodesAttrName.flushLast();\r\n                } else {\r\n                    lastTagNode.attr(tokenValue, tokenValue);\r\n                }\r\n            } else if (token.isText()) {\r\n                if (isNested) {\r\n                    lastTagNode.append(tokenValue);\r\n                } else {\r\n                    appendNodes(tokenValue);\r\n                }\r\n            } else if (token.isTag()) {\r\n                // if tag is not allowed, just past it as is\r\n                appendNodes(token.toString());\r\n            }\r\n        } else if (token.isText()) {\r\n            appendNodes(tokenValue);\r\n        } else if (token.isTag()) {\r\n            // if tag is not allowed, just past it as is\r\n            appendNodes(token.toString());\r\n        }\r\n    };\r\n    /**\r\n   * @private\r\n   * @param {Token} token\r\n   */ const onToken = (token)=>{\r\n        if (token.isTag()) {\r\n            handleTag(token);\r\n        } else {\r\n            handleNode(token);\r\n        }\r\n    };\r\n    tokenizer = (opts.createTokenizer ? opts.createTokenizer : createLexer)(input, {\r\n        onToken,\r\n        openTag,\r\n        closeTag,\r\n        onlyAllowTags: options.onlyAllowTags,\r\n        contextFreeTags: options.contextFreeTags,\r\n        enableEscapeTags: options.enableEscapeTags\r\n    });\r\n    // eslint-disable-next-line no-unused-vars\r\n    const tokens = tokenizer.tokenize();\r\n    return nodes.toArray();\r\n};\r\nexport { parse };\r\nexport default parse;\r\n", "/* eslint-disable no-plusplus */ const isObj = (value)=>typeof value === 'object';\r\nconst isBool = (value)=>typeof value === 'boolean';\r\nexport function iterate(t, cb) {\r\n    const tree = t;\r\n    if (Array.isArray(tree)) {\r\n        for(let idx = 0; idx < tree.length; idx++){\r\n            tree[idx] = iterate(cb(tree[idx]), cb);\r\n        }\r\n    } else if (tree && isObj(tree) && tree.content) {\r\n        iterate(tree.content, cb);\r\n    }\r\n    return tree;\r\n}\r\nexport function same(expected, actual) {\r\n    if (typeof expected !== typeof actual) {\r\n        return false;\r\n    }\r\n    if (!isObj(expected) || expected === null) {\r\n        return expected === actual;\r\n    }\r\n    if (Array.isArray(expected)) {\r\n        return expected.every((exp)=>[].some.call(actual, (act)=>same(exp, act)));\r\n    }\r\n    return Object.keys(expected).every((key)=>{\r\n        const ao = actual[key];\r\n        const eo = expected[key];\r\n        if (isObj(eo) && eo !== null && ao !== null) {\r\n            return same(eo, ao);\r\n        }\r\n        if (isBool(eo)) {\r\n            return eo !== (ao === null);\r\n        }\r\n        return ao === eo;\r\n    });\r\n}\r\nexport function match(expression, cb) {\r\n    return Array.isArray(expression) ? iterate(this, (node)=>{\r\n        for(let idx = 0; idx < expression.length; idx++){\r\n            if (same(expression[idx], node)) {\r\n                return cb(node);\r\n            }\r\n        }\r\n        return node;\r\n    }) : iterate(this, (node)=>same(expression, node) ? cb(node) : node);\r\n}\r\n", "import { parse } from '@bbob/parser';\r\nimport { iterate, match } from './utils';\r\nfunction walk(cb) {\r\n    return iterate(this, cb);\r\n}\r\nexport default function bbob(plugs) {\r\n    const plugins = typeof plugs === 'function' ? [\r\n        plugs\r\n    ] : plugs || [];\r\n    let options = {\r\n        skipParse: false\r\n    };\r\n    return {\r\n        process (input, opts) {\r\n            options = opts || {};\r\n            const parseFn = options.parser || parse;\r\n            const renderFn = options.render;\r\n            const data = options.data || null;\r\n            if (typeof parseFn !== 'function') {\r\n                throw new Error('\"parser\" is not a function, please pass to \"process(input, { parser })\" right function');\r\n            }\r\n            let tree = options.skipParse ? input || [] : parseFn(input, options);\r\n            // raw tree before modification with plugins\r\n            const raw = tree;\r\n            tree.messages = [];\r\n            tree.options = options;\r\n            tree.walk = walk;\r\n            tree.match = match;\r\n            plugins.forEach((plugin)=>{\r\n                tree = plugin(tree, {\r\n                    parse: parseFn,\r\n                    render: renderFn,\r\n                    iterate,\r\n                    match,\r\n                    data\r\n                }) || tree;\r\n            });\r\n            return {\r\n                get html () {\r\n                    if (typeof renderFn !== 'function') {\r\n                        throw new Error('\"render\" function not defined, please pass to \"process(input, { render })\"');\r\n                    }\r\n                    return renderFn(tree, tree.options);\r\n                },\r\n                tree,\r\n                raw,\r\n                messages: tree.messages\r\n            };\r\n        }\r\n    };\r\n}\r\n", "import core from '@bbob/core';\r\nimport { attrsToString } from '@bbob/plugin-helper';\r\nconst SELFCLOSE_END_TAG = '/>';\r\nconst CLOSE_START_TAG = '</';\r\nconst START_TAG = '<';\r\nconst END_TAG = '>';\r\nconst renderNode = (node, { stripTags =false  })=>{\r\n    if (!node) return '';\r\n    const type = typeof node;\r\n    if (type === 'string' || type === 'number') {\r\n        return node;\r\n    }\r\n    if (type === 'object') {\r\n        if (stripTags === true) {\r\n            // eslint-disable-next-line no-use-before-define\r\n            return renderNodes(node.content, {\r\n                stripTags\r\n            });\r\n        }\r\n        if (node.content === null) {\r\n            return [\r\n                START_TAG,\r\n                node.tag,\r\n                attrsToString(node.attrs),\r\n                SELFCLOSE_END_TAG\r\n            ].join('');\r\n        }\r\n        // eslint-disable-next-line no-use-before-define\r\n        return [\r\n            START_TAG,\r\n            node.tag,\r\n            attrsToString(node.attrs),\r\n            END_TAG,\r\n            renderNodes(node.content),\r\n            CLOSE_START_TAG,\r\n            node.tag,\r\n            END_TAG\r\n        ].join('');\r\n    }\r\n    if (Array.isArray(node)) {\r\n        // eslint-disable-next-line no-use-before-define\r\n        return renderNodes(node, {\r\n            stripTags\r\n        });\r\n    }\r\n    return '';\r\n};\r\nconst renderNodes = (nodes, { stripTags =false  } = {})=>[].concat(nodes).reduce((r, node)=>r + renderNode(node, {\r\n            stripTags\r\n        }), '');\r\nconst toHTML = (source, plugins, options)=>core(plugins).process(source, {\r\n        ...options,\r\n        render: renderNodes\r\n    }).html;\r\nexport const render = renderNodes;\r\nexport default toHTML;\r\n"],
  "mappings": "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",
  "names": []
}
