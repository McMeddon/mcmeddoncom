{
  "version": 3,
  "sources": ["../../@bbob/parser/es/Token.js", "../../@bbob/parser/es/utils.js", "../../@bbob/parser/es/lexer.js", "../../@bbob/parser/es/parse.js", "../../@bbob/core/es/utils.js", "../../@bbob/core/es/index.js", "../../@bbob/html/es/index.js"],
  "sourcesContent": ["import { OPEN_BRAKET, CLOSE_BRAKET, SLASH } from '@bbob/plugin-helper';\n// type, value, line, row,\nconst TOKEN_TYPE_ID = 'type'; // 0;\nconst TOKEN_VALUE_ID = 'value'; // 1;\nconst TOKEN_COLUMN_ID = 'row'; // 2;\nconst TOKEN_LINE_ID = 'line'; // 3;\nconst TOKEN_TYPE_WORD = 1; // 'word';\nconst TOKEN_TYPE_TAG = 2; // 'tag';\nconst TOKEN_TYPE_ATTR_NAME = 3; // 'attr-name';\nconst TOKEN_TYPE_ATTR_VALUE = 4; // 'attr-value';\nconst TOKEN_TYPE_SPACE = 5; // 'space';\nconst TOKEN_TYPE_NEW_LINE = 6; // 'new-line';\n/**\n * @param {Token} token\n * @returns {string}\n */ const getTokenValue = (token)=>{\n    if (token && typeof token[TOKEN_VALUE_ID] !== 'undefined') {\n        return token[TOKEN_VALUE_ID];\n    }\n    return '';\n};\n/**\n * @param {Token}token\n * @returns {number}\n */ const getTokenLine = (token)=>token && token[TOKEN_LINE_ID] || 0;\nconst getTokenColumn = (token)=>token && token[TOKEN_COLUMN_ID] || 0;\n/**\n * @param {Token} token\n * @returns {boolean}\n */ const isTextToken = (token)=>{\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_SPACE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_NEW_LINE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_WORD;\n    }\n    return false;\n};\n/**\n * @param {Token} token\n * @returns {boolean}\n */ const isTagToken = (token)=>{\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_TAG;\n    }\n    return false;\n};\nconst isTagEnd = (token)=>getTokenValue(token).charCodeAt(0) === SLASH.charCodeAt(0);\nconst isTagStart = (token)=>!isTagEnd(token);\nconst isAttrNameToken = (token)=>{\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_NAME;\n    }\n    return false;\n};\n/**\n * @param {Token} token\n * @returns {boolean}\n */ const isAttrValueToken = (token)=>{\n    if (token && typeof token[TOKEN_TYPE_ID] !== 'undefined') {\n        return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_VALUE;\n    }\n    return false;\n};\nconst getTagName = (token)=>{\n    const value = getTokenValue(token);\n    return isTagEnd(token) ? value.slice(1) : value;\n};\nconst convertTagToText = (token)=>{\n    let text = OPEN_BRAKET;\n    text += getTokenValue(token);\n    text += CLOSE_BRAKET;\n    return text;\n};\nclass Token {\n    isEmpty() {\n        // eslint-disable-next-line no-restricted-globals\n        return isNaN(this[TOKEN_TYPE_ID]);\n    }\n    isText() {\n        return isTextToken(this);\n    }\n    isTag() {\n        return isTagToken(this);\n    }\n    isAttrName() {\n        return isAttrNameToken(this);\n    }\n    isAttrValue() {\n        return isAttrValueToken(this);\n    }\n    isStart() {\n        return isTagStart(this);\n    }\n    isEnd() {\n        return isTagEnd(this);\n    }\n    getName() {\n        return getTagName(this);\n    }\n    getValue() {\n        return getTokenValue(this);\n    }\n    getLine() {\n        return getTokenLine(this);\n    }\n    getColumn() {\n        return getTokenColumn(this);\n    }\n    toString() {\n        return convertTagToText(this);\n    }\n    /**\n   * @param {String} type\n   * @param {String} value\n   * @param line\n   * @param row\n   */ constructor(type, value, line, row){\n        this[TOKEN_TYPE_ID] = Number(type);\n        this[TOKEN_VALUE_ID] = String(value);\n        this[TOKEN_LINE_ID] = Number(line);\n        this[TOKEN_COLUMN_ID] = Number(row);\n    }\n}\nexport const TYPE_ID = TOKEN_TYPE_ID;\nexport const VALUE_ID = TOKEN_VALUE_ID;\nexport const LINE_ID = TOKEN_LINE_ID;\nexport const COLUMN_ID = TOKEN_COLUMN_ID;\nexport const TYPE_WORD = TOKEN_TYPE_WORD;\nexport const TYPE_TAG = TOKEN_TYPE_TAG;\nexport const TYPE_ATTR_NAME = TOKEN_TYPE_ATTR_NAME;\nexport const TYPE_ATTR_VALUE = TOKEN_TYPE_ATTR_VALUE;\nexport const TYPE_SPACE = TOKEN_TYPE_SPACE;\nexport const TYPE_NEW_LINE = TOKEN_TYPE_NEW_LINE;\nexport { Token };\nexport default Token;\n", "import { QUOTEMARK, BACKSLASH } from '@bbob/plugin-helper';\nfunction CharGrabber(source, options) {\n    const cursor = {\n        pos: 0,\n        len: source.length\n    };\n    const substrUntilChar = (char)=>{\n        const { pos  } = cursor;\n        const idx = source.indexOf(char, pos);\n        return idx >= 0 ? source.substring(pos, idx) : '';\n    };\n    const includes = (val)=>source.indexOf(val, cursor.pos) >= 0;\n    const hasNext = ()=>cursor.len > cursor.pos;\n    const isLast = ()=>cursor.pos === cursor.len;\n    const skip = (num = 1, silent)=>{\n        cursor.pos += num;\n        if (options && options.onSkip && !silent) {\n            options.onSkip();\n        }\n    };\n    const rest = ()=>source.substring(cursor.pos);\n    const grabN = (num = 0)=>source.substring(cursor.pos, cursor.pos + num);\n    const curr = ()=>source[cursor.pos];\n    const prev = ()=>{\n        const prevPos = cursor.pos - 1;\n        return typeof source[prevPos] !== 'undefined' ? source[prevPos] : null;\n    };\n    const next = ()=>{\n        const nextPos = cursor.pos + 1;\n        return nextPos <= source.length - 1 ? source[nextPos] : null;\n    };\n    const grabWhile = (cond, silent)=>{\n        let start = 0;\n        if (hasNext()) {\n            start = cursor.pos;\n            while(hasNext() && cond(curr())){\n                skip(1, silent);\n            }\n        }\n        return source.substring(start, cursor.pos);\n    };\n    /**\n   * @type {skip}\n   */ this.skip = skip;\n    /**\n   * @returns {Boolean}\n   */ this.hasNext = hasNext;\n    /**\n   * @returns {String}\n   */ this.getCurr = curr;\n    /**\n   * @returns {String}\n   */ this.getRest = rest;\n    /**\n   * @returns {String}\n   */ this.getNext = next;\n    /**\n   * @returns {String}\n   */ this.getPrev = prev;\n    /**\n   * @returns {Boolean}\n   */ this.isLast = isLast;\n    /**\n   * @returns {Boolean}\n   */ this.includes = includes;\n    /**\n   * @param {Function} cond\n   * @param {Boolean} silent\n   * @return {String}\n   */ this.grabWhile = grabWhile;\n    /**\n   * @param {Number} num\n   * @return {String}\n   */ this.grabN = grabN;\n    /**\n   * Grabs rest of string until it find a char\n   * @param {String} char\n   * @return {String}\n   */ this.substrUntilChar = substrUntilChar;\n}\n/**\n * Creates a grabber wrapper for source string, that helps to iterate over string char by char\n * @param {String} source\n * @param {Object} options\n * @param {Function} options.onSkip\n * @return CharGrabber\n */ export const createCharGrabber = (source, options)=>new CharGrabber(source, options);\n/**\n * Trims string from start and end by char\n * @example\n *  trimChar('*hello*', '*') ==> 'hello'\n * @param {String} str\n * @param {String} charToRemove\n * @returns {String}\n */ export const trimChar = (str, charToRemove)=>{\n    while(str.charAt(0) === charToRemove){\n        // eslint-disable-next-line no-param-reassign\n        str = str.substring(1);\n    }\n    while(str.charAt(str.length - 1) === charToRemove){\n        // eslint-disable-next-line no-param-reassign\n        str = str.substring(0, str.length - 1);\n    }\n    return str;\n};\n/**\n * Unquotes \\\" to \"\n * @param str\n * @return {String}\n */ export const unquote = (str)=>str.replace(BACKSLASH + QUOTEMARK, QUOTEMARK);\nfunction NodeList(values = []) {\n    const nodes = values;\n    const getLast = ()=>Array.isArray(nodes) && nodes.length > 0 && typeof nodes[nodes.length - 1] !== 'undefined' ? nodes[nodes.length - 1] : null;\n    const flushLast = ()=>nodes.length ? nodes.pop() : false;\n    const push = (value)=>nodes.push(value);\n    const toArray = ()=>nodes;\n    this.push = push;\n    this.toArray = toArray;\n    this.getLast = getLast;\n    this.flushLast = flushLast;\n}\n/**\n *\n * @param values\n * @return {NodeList}\n */ export const createList = (values = [])=>new NodeList(values);\n", "/* eslint-disable no-plusplus,no-param-reassign */ import { OPEN_BRAKET, CLOSE_BRAKET, QUOTEMARK, BACKSLASH, SLASH, SPACE, TAB, EQ, N } from '@bbob/plugin-helper';\nimport { Token, TYPE_ATTR_NAME, TYPE_ATTR_VALUE, TYPE_NEW_LINE, TYPE_SPACE, TYPE_TAG, TYPE_WORD } from './Token';\nimport { createCharGrabber, trimChar, unquote } from './utils';\n// for cases <!-- -->\nconst EM = '!';\n/**\n * Creates a Token entity class\n * @param {Number} type\n * @param {String} value\n * @param {Number} r line number\n * @param {Number} cl char number in line\n */ const createToken = (type, value, r = 0, cl = 0)=>new Token(type, value, r, cl);\n/**\n * @typedef {Object} Lexer\n * @property {Function} tokenize\n * @property {Function} isTokenNested\n */ /**\n * @param {String} buffer\n * @param {Object} options\n * @param {Function} options.onToken\n * @param {String} options.openTag\n * @param {String} options.closeTag\n * @param {Boolean} options.enableEscapeTags\n * @return {Lexer}\n */ function createLexer(buffer, options = {}) {\n    const STATE_WORD = 0;\n    const STATE_TAG = 1;\n    const STATE_TAG_ATTRS = 2;\n    const TAG_STATE_NAME = 0;\n    const TAG_STATE_ATTR = 1;\n    const TAG_STATE_VALUE = 2;\n    let row = 0;\n    let col = 0;\n    let tokenIndex = -1;\n    let stateMode = STATE_WORD;\n    let tagMode = TAG_STATE_NAME;\n    let contextFreeTag = '';\n    const tokens = new Array(Math.floor(buffer.length));\n    const openTag = options.openTag || OPEN_BRAKET;\n    const closeTag = options.closeTag || CLOSE_BRAKET;\n    const escapeTags = !!options.enableEscapeTags;\n    const contextFreeTags = options.contextFreeTags || [];\n    const onToken = options.onToken || (()=>{});\n    const RESERVED_CHARS = [\n        closeTag,\n        openTag,\n        QUOTEMARK,\n        BACKSLASH,\n        SPACE,\n        TAB,\n        EQ,\n        N,\n        EM\n    ];\n    const NOT_CHAR_TOKENS = [\n        openTag,\n        SPACE,\n        TAB,\n        N\n    ];\n    const WHITESPACES = [\n        SPACE,\n        TAB\n    ];\n    const SPECIAL_CHARS = [\n        EQ,\n        SPACE,\n        TAB\n    ];\n    const isCharReserved = (char)=>RESERVED_CHARS.indexOf(char) >= 0;\n    const isNewLine = (char)=>char === N;\n    const isWhiteSpace = (char)=>WHITESPACES.indexOf(char) >= 0;\n    const isCharToken = (char)=>NOT_CHAR_TOKENS.indexOf(char) === -1;\n    const isSpecialChar = (char)=>SPECIAL_CHARS.indexOf(char) >= 0;\n    const isEscapableChar = (char)=>char === openTag || char === closeTag || char === BACKSLASH;\n    const isEscapeChar = (char)=>char === BACKSLASH;\n    const onSkip = ()=>{\n        col++;\n    };\n    const unq = (val)=>unquote(trimChar(val, QUOTEMARK));\n    const checkContextFreeMode = (name, isClosingTag)=>{\n        if (contextFreeTag !== '' && isClosingTag) {\n            contextFreeTag = '';\n        }\n        if (contextFreeTag === '' && contextFreeTags.includes(name)) {\n            contextFreeTag = name;\n        }\n    };\n    const chars = createCharGrabber(buffer, {\n        onSkip\n    });\n    /**\n   * Emits newly created token to subscriber\n   * @param {Number} type\n   * @param {String} value\n   */ function emitToken(type, value) {\n        const token = createToken(type, value, row, col);\n        onToken(token);\n        tokenIndex += 1;\n        tokens[tokenIndex] = token;\n    }\n    function nextTagState(tagChars, isSingleValueTag) {\n        if (tagMode === TAG_STATE_ATTR) {\n            const validAttrName = (char)=>!(char === EQ || isWhiteSpace(char));\n            const name = tagChars.grabWhile(validAttrName);\n            const isEnd = tagChars.isLast();\n            const isValue = tagChars.getCurr() !== EQ;\n            tagChars.skip();\n            if (isEnd || isValue) {\n                emitToken(TYPE_ATTR_VALUE, unq(name));\n            } else {\n                emitToken(TYPE_ATTR_NAME, name);\n            }\n            if (isEnd) {\n                return TAG_STATE_NAME;\n            }\n            if (isValue) {\n                return TAG_STATE_ATTR;\n            }\n            return TAG_STATE_VALUE;\n        }\n        if (tagMode === TAG_STATE_VALUE) {\n            let stateSpecial = false;\n            const validAttrValue = (char)=>{\n                // const isEQ = char === EQ;\n                const isQM = char === QUOTEMARK;\n                const prevChar = tagChars.getPrev();\n                const nextChar = tagChars.getNext();\n                const isPrevSLASH = prevChar === BACKSLASH;\n                const isNextEQ = nextChar === EQ;\n                const isWS = isWhiteSpace(char);\n                // const isPrevWS = isWhiteSpace(prevChar);\n                const isNextWS = isWhiteSpace(nextChar);\n                if (stateSpecial && isSpecialChar(char)) {\n                    return true;\n                }\n                if (isQM && !isPrevSLASH) {\n                    stateSpecial = !stateSpecial;\n                    if (!stateSpecial && !(isNextEQ || isNextWS)) {\n                        return false;\n                    }\n                }\n                if (!isSingleValueTag) {\n                    return isWS === false;\n                // return (isEQ || isWS) === false;\n                }\n                return true;\n            };\n            const name1 = tagChars.grabWhile(validAttrValue);\n            tagChars.skip();\n            emitToken(TYPE_ATTR_VALUE, unq(name1));\n            if (tagChars.isLast()) {\n                return TAG_STATE_NAME;\n            }\n            return TAG_STATE_ATTR;\n        }\n        const validName = (char)=>!(char === EQ || isWhiteSpace(char) || tagChars.isLast());\n        const name2 = tagChars.grabWhile(validName);\n        emitToken(TYPE_TAG, name2);\n        checkContextFreeMode(name2);\n        tagChars.skip();\n        // in cases when we has [url=someval]GET[/url] and we dont need to parse all\n        if (isSingleValueTag) {\n            return TAG_STATE_VALUE;\n        }\n        const hasEQ = tagChars.includes(EQ);\n        return hasEQ ? TAG_STATE_ATTR : TAG_STATE_VALUE;\n    }\n    function stateTag() {\n        const currChar = chars.getCurr();\n        const nextChar = chars.getNext();\n        chars.skip();\n        // detect case where we have '[My word [tag][/tag]' or we have '[My last line word'\n        const substr = chars.substrUntilChar(closeTag);\n        const hasInvalidChars = substr.length === 0 || substr.indexOf(openTag) >= 0;\n        if (isCharReserved(nextChar) || hasInvalidChars || chars.isLast()) {\n            emitToken(TYPE_WORD, currChar);\n            return STATE_WORD;\n        }\n        // [myTag   ]\n        const isNoAttrsInTag = substr.indexOf(EQ) === -1;\n        // [/myTag]\n        const isClosingTag = substr[0] === SLASH;\n        if (isNoAttrsInTag || isClosingTag) {\n            const name = chars.grabWhile((char)=>char !== closeTag);\n            chars.skip(); // skip closeTag\n            emitToken(TYPE_TAG, name);\n            checkContextFreeMode(name, isClosingTag);\n            return STATE_WORD;\n        }\n        return STATE_TAG_ATTRS;\n    }\n    function stateAttrs() {\n        const silent = true;\n        const tagStr = chars.grabWhile((char)=>char !== closeTag, silent);\n        const tagGrabber = createCharGrabber(tagStr, {\n            onSkip\n        });\n        const hasSpace = tagGrabber.includes(SPACE);\n        tagMode = TAG_STATE_NAME;\n        while(tagGrabber.hasNext()){\n            tagMode = nextTagState(tagGrabber, !hasSpace);\n        }\n        chars.skip(); // skip closeTag\n        return STATE_WORD;\n    }\n    function stateWord() {\n        if (isNewLine(chars.getCurr())) {\n            emitToken(TYPE_NEW_LINE, chars.getCurr());\n            chars.skip();\n            col = 0;\n            row++;\n            return STATE_WORD;\n        }\n        if (isWhiteSpace(chars.getCurr())) {\n            const word = chars.grabWhile(isWhiteSpace);\n            emitToken(TYPE_SPACE, word);\n            return STATE_WORD;\n        }\n        if (chars.getCurr() === openTag) {\n            if (contextFreeTag) {\n                const fullTagLen = openTag.length + SLASH.length + contextFreeTag.length;\n                const fullTagName = `${openTag}${SLASH}${contextFreeTag}`;\n                const foundTag = chars.grabN(fullTagLen);\n                const isEndContextFreeMode = foundTag === fullTagName;\n                if (isEndContextFreeMode) {\n                    return STATE_TAG;\n                }\n            } else if (chars.includes(closeTag)) {\n                return STATE_TAG;\n            }\n            emitToken(TYPE_WORD, chars.getCurr());\n            chars.skip();\n            return STATE_WORD;\n        }\n        if (escapeTags) {\n            if (isEscapeChar(chars.getCurr())) {\n                const currChar = chars.getCurr();\n                const nextChar = chars.getNext();\n                chars.skip(); // skip the \\ without emitting anything\n                if (isEscapableChar(nextChar)) {\n                    chars.skip(); // skip past the [, ] or \\ as well\n                    emitToken(TYPE_WORD, nextChar);\n                    return STATE_WORD;\n                }\n                emitToken(TYPE_WORD, currChar);\n                return STATE_WORD;\n            }\n            const isChar = (char)=>isCharToken(char) && !isEscapeChar(char);\n            const word1 = chars.grabWhile(isChar);\n            emitToken(TYPE_WORD, word1);\n            return STATE_WORD;\n        }\n        const word2 = chars.grabWhile(isCharToken);\n        emitToken(TYPE_WORD, word2);\n        return STATE_WORD;\n    }\n    function tokenize() {\n        stateMode = STATE_WORD;\n        while(chars.hasNext()){\n            switch(stateMode){\n                case STATE_TAG:\n                    stateMode = stateTag();\n                    break;\n                case STATE_TAG_ATTRS:\n                    stateMode = stateAttrs();\n                    break;\n                case STATE_WORD:\n                default:\n                    stateMode = stateWord();\n                    break;\n            }\n        }\n        tokens.length = tokenIndex + 1;\n        return tokens;\n    }\n    function isTokenNested(token) {\n        const value = openTag + SLASH + token.getValue();\n        // potential bottleneck\n        return buffer.indexOf(value) > -1;\n    }\n    return {\n        tokenize,\n        isTokenNested\n    };\n}\nexport const createTokenOfType = createToken;\nexport { createLexer };\n", "import { TagNode, CLOSE_BRAKET, OPEN_BRAKET, isTagNode } from '@bbob/plugin-helper';\nimport { createLexer } from './lexer';\nimport { createList } from './utils';\n/**\n * @public\n * @param {String} input\n * @param {Object} opts\n * @param {Function} opts.createTokenizer\n * @param {Array<string>} opts.onlyAllowTags\n * @param {Array<string>} opts.contextFreeTags\n * @param {Boolean} opts.enableEscapeTags\n * @param {String} opts.openTag\n * @param {String} opts.closeTag\n * @return {Array}\n */ const parse = (input, opts = {})=>{\n    const options = opts;\n    const openTag = options.openTag || OPEN_BRAKET;\n    const closeTag = options.closeTag || CLOSE_BRAKET;\n    let tokenizer = null;\n    /**\n   * Result AST of nodes\n   * @private\n   * @type {NodeList}\n   */ const nodes = createList();\n    /**\n   * Temp buffer of nodes that's nested to another node\n   * @private\n   * @type {NodeList}\n   */ const nestedNodes = createList();\n    /**\n   * Temp buffer of nodes [tag..]...[/tag]\n   * @private\n   * @type {NodeList}\n   */ const tagNodes = createList();\n    /**\n   * Temp buffer of tag attributes\n   * @private\n   * @type {NodeList}\n   */ const tagNodesAttrName = createList();\n    /**\n   * Cache for nested tags checks\n   */ const nestedTagsMap = new Set();\n    /**\n   *\n   * @param token\n   * @returns {boolean}\n   */ const isTokenNested = (token)=>{\n        const value = token.getValue();\n        if (!nestedTagsMap.has(value) && tokenizer.isTokenNested && tokenizer.isTokenNested(token)) {\n            nestedTagsMap.add(value);\n            return true;\n        }\n        return nestedTagsMap.has(value);\n    };\n    /**\n   * @param tagName\n   * @returns {boolean}\n   */ const isTagNested = (tagName)=>Boolean(nestedTagsMap.has(tagName));\n    /**\n   * @private\n   * @param {String} value\n   * @return {boolean}\n   */ const isAllowedTag = (value)=>{\n        if (options.onlyAllowTags && options.onlyAllowTags.length) {\n            return options.onlyAllowTags.indexOf(value) >= 0;\n        }\n        return true;\n    };\n    /**\n   * Flushes temp tag nodes and its attributes buffers\n   * @private\n   * @return {Array}\n   */ const flushTagNodes = ()=>{\n        if (tagNodes.flushLast()) {\n            tagNodesAttrName.flushLast();\n        }\n    };\n    /**\n   * @private\n   * @return {Array}\n   */ const getNodes = ()=>{\n        const lastNestedNode = nestedNodes.getLast();\n        if (lastNestedNode && Array.isArray(lastNestedNode.content)) {\n            return lastNestedNode.content;\n        }\n        return nodes.toArray();\n    };\n    /**\n   * @private\n   * @param {string|TagNode} node\n   */ const appendNodes = (node)=>{\n        const items = getNodes();\n        if (Array.isArray(items)) {\n            if (isTagNode(node)) {\n                if (isAllowedTag(node.tag)) {\n                    items.push(node.toTagNode());\n                } else {\n                    items.push(node.toTagStart({\n                        openTag,\n                        closeTag\n                    }));\n                    if (node.content.length) {\n                        node.content.forEach((item)=>{\n                            items.push(item);\n                        });\n                        items.push(node.toTagEnd({\n                            openTag,\n                            closeTag\n                        }));\n                    }\n                }\n            } else {\n                items.push(node);\n            }\n        }\n    };\n    /**\n   * @private\n   * @param {Token} token\n   */ const handleTagStart = (token)=>{\n        flushTagNodes();\n        const tagNode = TagNode.create(token.getValue());\n        const isNested = isTokenNested(token);\n        tagNodes.push(tagNode);\n        if (isNested) {\n            nestedNodes.push(tagNode);\n        } else {\n            appendNodes(tagNode, token);\n        }\n    };\n    /**\n   * @private\n   * @param {Token} token\n   */ const handleTagEnd = (token)=>{\n        flushTagNodes();\n        const lastNestedNode = nestedNodes.flushLast();\n        if (lastNestedNode) {\n            appendNodes(lastNestedNode, token);\n        } else if (typeof options.onError === 'function') {\n            const tag = token.getValue();\n            const line = token.getLine();\n            const column = token.getColumn();\n            options.onError({\n                message: `Inconsistent tag '${tag}' on line ${line} and column ${column}`,\n                tagName: tag,\n                lineNumber: line,\n                columnNumber: column\n            });\n        }\n    };\n    /**\n   * @private\n   * @param {Token} token\n   */ const handleTag = (token)=>{\n        // [tag]\n        if (token.isStart()) {\n            handleTagStart(token);\n        }\n        // [/tag]\n        if (token.isEnd()) {\n            handleTagEnd(token);\n        }\n    };\n    /**\n   * @private\n   * @param {Token} token\n   */ const handleNode = (token)=>{\n        /**\n     * @type {TagNode}\n     */ const lastTagNode = tagNodes.getLast();\n        const tokenValue = token.getValue();\n        const isNested = isTagNested(token);\n        if (lastTagNode) {\n            if (token.isAttrName()) {\n                tagNodesAttrName.push(tokenValue);\n                lastTagNode.attr(tagNodesAttrName.getLast(), '');\n            } else if (token.isAttrValue()) {\n                const attrName = tagNodesAttrName.getLast();\n                if (attrName) {\n                    lastTagNode.attr(attrName, tokenValue);\n                    tagNodesAttrName.flushLast();\n                } else {\n                    lastTagNode.attr(tokenValue, tokenValue);\n                }\n            } else if (token.isText()) {\n                if (isNested) {\n                    lastTagNode.append(tokenValue);\n                } else {\n                    appendNodes(tokenValue);\n                }\n            } else if (token.isTag()) {\n                // if tag is not allowed, just past it as is\n                appendNodes(token.toString());\n            }\n        } else if (token.isText()) {\n            appendNodes(tokenValue);\n        } else if (token.isTag()) {\n            // if tag is not allowed, just past it as is\n            appendNodes(token.toString());\n        }\n    };\n    /**\n   * @private\n   * @param {Token} token\n   */ const onToken = (token)=>{\n        if (token.isTag()) {\n            handleTag(token);\n        } else {\n            handleNode(token);\n        }\n    };\n    tokenizer = (opts.createTokenizer ? opts.createTokenizer : createLexer)(input, {\n        onToken,\n        openTag,\n        closeTag,\n        onlyAllowTags: options.onlyAllowTags,\n        contextFreeTags: options.contextFreeTags,\n        enableEscapeTags: options.enableEscapeTags\n    });\n    // eslint-disable-next-line no-unused-vars\n    const tokens = tokenizer.tokenize();\n    return nodes.toArray();\n};\nexport { parse };\nexport default parse;\n", "/* eslint-disable no-plusplus */ const isObj = (value)=>typeof value === 'object';\nconst isBool = (value)=>typeof value === 'boolean';\nexport function iterate(t, cb) {\n    const tree = t;\n    if (Array.isArray(tree)) {\n        for(let idx = 0; idx < tree.length; idx++){\n            tree[idx] = iterate(cb(tree[idx]), cb);\n        }\n    } else if (tree && isObj(tree) && tree.content) {\n        iterate(tree.content, cb);\n    }\n    return tree;\n}\nexport function same(expected, actual) {\n    if (typeof expected !== typeof actual) {\n        return false;\n    }\n    if (!isObj(expected) || expected === null) {\n        return expected === actual;\n    }\n    if (Array.isArray(expected)) {\n        return expected.every((exp)=>[].some.call(actual, (act)=>same(exp, act)));\n    }\n    return Object.keys(expected).every((key)=>{\n        const ao = actual[key];\n        const eo = expected[key];\n        if (isObj(eo) && eo !== null && ao !== null) {\n            return same(eo, ao);\n        }\n        if (isBool(eo)) {\n            return eo !== (ao === null);\n        }\n        return ao === eo;\n    });\n}\nexport function match(expression, cb) {\n    return Array.isArray(expression) ? iterate(this, (node)=>{\n        for(let idx = 0; idx < expression.length; idx++){\n            if (same(expression[idx], node)) {\n                return cb(node);\n            }\n        }\n        return node;\n    }) : iterate(this, (node)=>same(expression, node) ? cb(node) : node);\n}\n", "import { parse } from '@bbob/parser';\nimport { iterate, match } from './utils';\nfunction walk(cb) {\n    return iterate(this, cb);\n}\nexport default function bbob(plugs) {\n    const plugins = typeof plugs === 'function' ? [\n        plugs\n    ] : plugs || [];\n    let options = {\n        skipParse: false\n    };\n    return {\n        process (input, opts) {\n            options = opts || {};\n            const parseFn = options.parser || parse;\n            const renderFn = options.render;\n            const data = options.data || null;\n            if (typeof parseFn !== 'function') {\n                throw new Error('\"parser\" is not a function, please pass to \"process(input, { parser })\" right function');\n            }\n            let tree = options.skipParse ? input || [] : parseFn(input, options);\n            // raw tree before modification with plugins\n            const raw = tree;\n            tree.messages = [];\n            tree.options = options;\n            tree.walk = walk;\n            tree.match = match;\n            plugins.forEach((plugin)=>{\n                tree = plugin(tree, {\n                    parse: parseFn,\n                    render: renderFn,\n                    iterate,\n                    match,\n                    data\n                }) || tree;\n            });\n            return {\n                get html () {\n                    if (typeof renderFn !== 'function') {\n                        throw new Error('\"render\" function not defined, please pass to \"process(input, { render })\"');\n                    }\n                    return renderFn(tree, tree.options);\n                },\n                tree,\n                raw,\n                messages: tree.messages\n            };\n        }\n    };\n}\n", "import core from '@bbob/core';\nimport { attrsToString } from '@bbob/plugin-helper';\nconst SELFCLOSE_END_TAG = '/>';\nconst CLOSE_START_TAG = '</';\nconst START_TAG = '<';\nconst END_TAG = '>';\nconst renderNode = (node, { stripTags =false  })=>{\n    if (!node) return '';\n    const type = typeof node;\n    if (type === 'string' || type === 'number') {\n        return node;\n    }\n    if (type === 'object') {\n        if (stripTags === true) {\n            // eslint-disable-next-line no-use-before-define\n            return renderNodes(node.content, {\n                stripTags\n            });\n        }\n        if (node.content === null) {\n            return [\n                START_TAG,\n                node.tag,\n                attrsToString(node.attrs),\n                SELFCLOSE_END_TAG\n            ].join('');\n        }\n        // eslint-disable-next-line no-use-before-define\n        return [\n            START_TAG,\n            node.tag,\n            attrsToString(node.attrs),\n            END_TAG,\n            renderNodes(node.content),\n            CLOSE_START_TAG,\n            node.tag,\n            END_TAG\n        ].join('');\n    }\n    if (Array.isArray(node)) {\n        // eslint-disable-next-line no-use-before-define\n        return renderNodes(node, {\n            stripTags\n        });\n    }\n    return '';\n};\nconst renderNodes = (nodes, { stripTags =false  } = {})=>[].concat(nodes).reduce((r, node)=>r + renderNode(node, {\n            stripTags\n        }), '');\nconst toHTML = (source, plugins, options)=>core(plugins).process(source, {\n        ...options,\n        render: renderNodes\n    }).html;\nexport const render = renderNodes;\nexport default toHTML;\n"],
  "mappings": ";;;;;;;;;;;;;;;;AAEA,IAAM,gBAAgB;AACtB,IAAM,iBAAiB;AACvB,IAAM,kBAAkB;AACxB,IAAM,gBAAgB;AACtB,IAAM,kBAAkB;AACxB,IAAM,iBAAiB;AACvB,IAAM,uBAAuB;AAC7B,IAAM,wBAAwB;AAC9B,IAAM,mBAAmB;AACzB,IAAM,sBAAsB;AAIxB,IAAM,gBAAgB,CAAC,UAAQ;AAC/B,MAAI,SAAS,OAAO,MAAM,cAAc,MAAM,aAAa;AACvD,WAAO,MAAM,cAAc;AAAA,EAC/B;AACA,SAAO;AACX;AAII,IAAM,eAAe,CAAC,UAAQ,SAAS,MAAM,aAAa,KAAK;AACnE,IAAM,iBAAiB,CAAC,UAAQ,SAAS,MAAM,eAAe,KAAK;AAI/D,IAAM,cAAc,CAAC,UAAQ;AAC7B,MAAI,SAAS,OAAO,MAAM,aAAa,MAAM,aAAa;AACtD,WAAO,MAAM,aAAa,MAAM,oBAAoB,MAAM,aAAa,MAAM,uBAAuB,MAAM,aAAa,MAAM;AAAA,EACjI;AACA,SAAO;AACX;AAII,IAAM,aAAa,CAAC,UAAQ;AAC5B,MAAI,SAAS,OAAO,MAAM,aAAa,MAAM,aAAa;AACtD,WAAO,MAAM,aAAa,MAAM;AAAA,EACpC;AACA,SAAO;AACX;AACA,IAAM,WAAW,CAAC,UAAQ,cAAc,KAAK,EAAE,WAAW,CAAC,MAAM,MAAM,WAAW,CAAC;AACnF,IAAM,aAAa,CAAC,UAAQ,CAAC,SAAS,KAAK;AAC3C,IAAM,kBAAkB,CAAC,UAAQ;AAC7B,MAAI,SAAS,OAAO,MAAM,aAAa,MAAM,aAAa;AACtD,WAAO,MAAM,aAAa,MAAM;AAAA,EACpC;AACA,SAAO;AACX;AAII,IAAM,mBAAmB,CAAC,UAAQ;AAClC,MAAI,SAAS,OAAO,MAAM,aAAa,MAAM,aAAa;AACtD,WAAO,MAAM,aAAa,MAAM;AAAA,EACpC;AACA,SAAO;AACX;AACA,IAAM,aAAa,CAAC,UAAQ;AACxB,QAAM,QAAQ,cAAc,KAAK;AACjC,SAAO,SAAS,KAAK,IAAI,MAAM,MAAM,CAAC,IAAI;AAC9C;AACA,IAAM,mBAAmB,CAAC,UAAQ;AAC9B,MAAI,OAAO;AACX,UAAQ,cAAc,KAAK;AAC3B,UAAQ;AACR,SAAO;AACX;AACA,IAAM,QAAN,MAAY;AAAA,EACR,UAAU;AAEN,WAAO,MAAM,KAAK,aAAa,CAAC;AAAA,EACpC;AAAA,EACA,SAAS;AACL,WAAO,YAAY,IAAI;AAAA,EAC3B;AAAA,EACA,QAAQ;AACJ,WAAO,WAAW,IAAI;AAAA,EAC1B;AAAA,EACA,aAAa;AACT,WAAO,gBAAgB,IAAI;AAAA,EAC/B;AAAA,EACA,cAAc;AACV,WAAO,iBAAiB,IAAI;AAAA,EAChC;AAAA,EACA,UAAU;AACN,WAAO,WAAW,IAAI;AAAA,EAC1B;AAAA,EACA,QAAQ;AACJ,WAAO,SAAS,IAAI;AAAA,EACxB;AAAA,EACA,UAAU;AACN,WAAO,WAAW,IAAI;AAAA,EAC1B;AAAA,EACA,WAAW;AACP,WAAO,cAAc,IAAI;AAAA,EAC7B;AAAA,EACA,UAAU;AACN,WAAO,aAAa,IAAI;AAAA,EAC5B;AAAA,EACA,YAAY;AACR,WAAO,eAAe,IAAI;AAAA,EAC9B;AAAA,EACA,WAAW;AACP,WAAO,iBAAiB,IAAI;AAAA,EAChC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAME,YAAY,MAAM,OAAO,MAAM,KAAI;AACjC,SAAK,aAAa,IAAI,OAAO,IAAI;AACjC,SAAK,cAAc,IAAI,OAAO,KAAK;AACnC,SAAK,aAAa,IAAI,OAAO,IAAI;AACjC,SAAK,eAAe,IAAI,OAAO,GAAG;AAAA,EACtC;AACJ;AAKO,IAAM,YAAY;AAClB,IAAM,WAAW;AACjB,IAAM,iBAAiB;AACvB,IAAM,kBAAkB;AACxB,IAAM,aAAa;AACnB,IAAM,gBAAgB;;;ACjI7B,SAAS,YAAY,QAAQ,SAAS;AAClC,QAAM,SAAS;AAAA,IACX,KAAK;AAAA,IACL,KAAK,OAAO;AAAA,EAChB;AACA,QAAM,kBAAkB,CAAC,SAAO;AAC5B,UAAM,EAAE,IAAK,IAAI;AACjB,UAAM,MAAM,OAAO,QAAQ,MAAM,GAAG;AACpC,WAAO,OAAO,IAAI,OAAO,UAAU,KAAK,GAAG,IAAI;AAAA,EACnD;AACA,QAAM,WAAW,CAAC,QAAM,OAAO,QAAQ,KAAK,OAAO,GAAG,KAAK;AAC3D,QAAM,UAAU,MAAI,OAAO,MAAM,OAAO;AACxC,QAAM,SAAS,MAAI,OAAO,QAAQ,OAAO;AACzC,QAAM,OAAO,CAAC,MAAM,GAAG,WAAS;AAC5B,WAAO,OAAO;AACd,QAAI,WAAW,QAAQ,UAAU,CAAC,QAAQ;AACtC,cAAQ,OAAO;AAAA,IACnB;AAAA,EACJ;AACA,QAAM,OAAO,MAAI,OAAO,UAAU,OAAO,GAAG;AAC5C,QAAM,QAAQ,CAAC,MAAM,MAAI,OAAO,UAAU,OAAO,KAAK,OAAO,MAAM,GAAG;AACtE,QAAM,OAAO,MAAI,OAAO,OAAO,GAAG;AAClC,QAAM,OAAO,MAAI;AACb,UAAM,UAAU,OAAO,MAAM;AAC7B,WAAO,OAAO,OAAO,OAAO,MAAM,cAAc,OAAO,OAAO,IAAI;AAAA,EACtE;AACA,QAAM,OAAO,MAAI;AACb,UAAM,UAAU,OAAO,MAAM;AAC7B,WAAO,WAAW,OAAO,SAAS,IAAI,OAAO,OAAO,IAAI;AAAA,EAC5D;AACA,QAAM,YAAY,CAAC,MAAM,WAAS;AAC9B,QAAI,QAAQ;AACZ,QAAI,QAAQ,GAAG;AACX,cAAQ,OAAO;AACf,aAAM,QAAQ,KAAK,KAAK,KAAK,CAAC,GAAE;AAC5B,aAAK,GAAG,MAAM;AAAA,MAClB;AAAA,IACJ;AACA,WAAO,OAAO,UAAU,OAAO,OAAO,GAAG;AAAA,EAC7C;AAGE,OAAK,OAAO;AAGZ,OAAK,UAAU;AAGf,OAAK,UAAU;AAGf,OAAK,UAAU;AAGf,OAAK,UAAU;AAGf,OAAK,UAAU;AAGf,OAAK,SAAS;AAGd,OAAK,WAAW;AAKhB,OAAK,YAAY;AAIjB,OAAK,QAAQ;AAKb,OAAK,kBAAkB;AAC7B;AAOW,IAAM,oBAAoB,CAAC,QAAQ,YAAU,IAAI,YAAY,QAAQ,OAAO;AAQ5E,IAAM,WAAW,CAAC,KAAK,iBAAe;AAC7C,SAAM,IAAI,OAAO,CAAC,MAAM,cAAa;AAEjC,UAAM,IAAI,UAAU,CAAC;AAAA,EACzB;AACA,SAAM,IAAI,OAAO,IAAI,SAAS,CAAC,MAAM,cAAa;AAE9C,UAAM,IAAI,UAAU,GAAG,IAAI,SAAS,CAAC;AAAA,EACzC;AACA,SAAO;AACX;AAKW,IAAM,UAAU,CAAC,QAAM,IAAI,QAAQ,YAAY,WAAW,SAAS;AAC9E,SAAS,SAAS,SAAS,CAAC,GAAG;AAC3B,QAAM,QAAQ;AACd,QAAM,UAAU,MAAI,MAAM,QAAQ,KAAK,KAAK,MAAM,SAAS,KAAK,OAAO,MAAM,MAAM,SAAS,CAAC,MAAM,cAAc,MAAM,MAAM,SAAS,CAAC,IAAI;AAC3I,QAAM,YAAY,MAAI,MAAM,SAAS,MAAM,IAAI,IAAI;AACnD,QAAM,OAAO,CAAC,UAAQ,MAAM,KAAK,KAAK;AACtC,QAAM,UAAU,MAAI;AACpB,OAAK,OAAO;AACZ,OAAK,UAAU;AACf,OAAK,UAAU;AACf,OAAK,YAAY;AACrB;AAKW,IAAM,aAAa,CAAC,SAAS,CAAC,MAAI,IAAI,SAAS,MAAM;;;ACzHhE,IAAM,KAAK;AAOP,IAAM,cAAc,CAAC,MAAM,OAAO,IAAI,GAAG,KAAK,MAAI,IAAI,MAAM,MAAM,OAAO,GAAG,EAAE;AAa9E,SAAS,YAAY,QAAQ,UAAU,CAAC,GAAG;AAC3C,QAAM,aAAa;AACnB,QAAM,YAAY;AAClB,QAAM,kBAAkB;AACxB,QAAM,iBAAiB;AACvB,QAAM,iBAAiB;AACvB,QAAM,kBAAkB;AACxB,MAAI,MAAM;AACV,MAAI,MAAM;AACV,MAAI,aAAa;AACjB,MAAI,YAAY;AAChB,MAAI,UAAU;AACd,MAAI,iBAAiB;AACrB,QAAM,SAAS,IAAI,MAAM,KAAK,MAAM,OAAO,MAAM,CAAC;AAClD,QAAM,UAAU,QAAQ,WAAW;AACnC,QAAM,WAAW,QAAQ,YAAY;AACrC,QAAM,aAAa,CAAC,CAAC,QAAQ;AAC7B,QAAM,kBAAkB,QAAQ,mBAAmB,CAAC;AACpD,QAAM,UAAU,QAAQ,YAAY,MAAI;AAAA,EAAC;AACzC,QAAM,iBAAiB;AAAA,IACnB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACA,QAAM,kBAAkB;AAAA,IACpB;AAAA,IACA;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACA,QAAM,cAAc;AAAA,IAChB;AAAA,IACA;AAAA,EACJ;AACA,QAAM,gBAAgB;AAAA,IAClB;AAAA,IACA;AAAA,IACA;AAAA,EACJ;AACA,QAAM,iBAAiB,CAAC,SAAO,eAAe,QAAQ,IAAI,KAAK;AAC/D,QAAM,YAAY,CAAC,SAAO,SAAS;AACnC,QAAM,eAAe,CAAC,SAAO,YAAY,QAAQ,IAAI,KAAK;AAC1D,QAAM,cAAc,CAAC,SAAO,gBAAgB,QAAQ,IAAI,MAAM;AAC9D,QAAM,gBAAgB,CAAC,SAAO,cAAc,QAAQ,IAAI,KAAK;AAC7D,QAAM,kBAAkB,CAAC,SAAO,SAAS,WAAW,SAAS,YAAY,SAAS;AAClF,QAAM,eAAe,CAAC,SAAO,SAAS;AACtC,QAAM,SAAS,MAAI;AACf;AAAA,EACJ;AACA,QAAM,MAAM,CAAC,QAAM,QAAQ,SAAS,KAAK,SAAS,CAAC;AACnD,QAAM,uBAAuB,CAAC,MAAM,iBAAe;AAC/C,QAAI,mBAAmB,MAAM,cAAc;AACvC,uBAAiB;AAAA,IACrB;AACA,QAAI,mBAAmB,MAAM,gBAAgB,SAAS,IAAI,GAAG;AACzD,uBAAiB;AAAA,IACrB;AAAA,EACJ;AACA,QAAM,QAAQ,kBAAkB,QAAQ;AAAA,IACpC;AAAA,EACJ,CAAC;AAKC,WAAS,UAAU,MAAM,OAAO;AAC9B,UAAM,QAAQ,YAAY,MAAM,OAAO,KAAK,GAAG;AAC/C,YAAQ,KAAK;AACb,kBAAc;AACd,WAAO,UAAU,IAAI;AAAA,EACzB;AACA,WAAS,aAAa,UAAU,kBAAkB;AAC9C,QAAI,YAAY,gBAAgB;AAC5B,YAAM,gBAAgB,CAAC,SAAO,EAAE,SAAS,MAAM,aAAa,IAAI;AAChE,YAAM,OAAO,SAAS,UAAU,aAAa;AAC7C,YAAM,QAAQ,SAAS,OAAO;AAC9B,YAAM,UAAU,SAAS,QAAQ,MAAM;AACvC,eAAS,KAAK;AACd,UAAI,SAAS,SAAS;AAClB,kBAAU,iBAAiB,IAAI,IAAI,CAAC;AAAA,MACxC,OAAO;AACH,kBAAU,gBAAgB,IAAI;AAAA,MAClC;AACA,UAAI,OAAO;AACP,eAAO;AAAA,MACX;AACA,UAAI,SAAS;AACT,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX;AACA,QAAI,YAAY,iBAAiB;AAC7B,UAAI,eAAe;AACnB,YAAM,iBAAiB,CAAC,SAAO;AAE3B,cAAM,OAAO,SAAS;AACtB,cAAM,WAAW,SAAS,QAAQ;AAClC,cAAM,WAAW,SAAS,QAAQ;AAClC,cAAM,cAAc,aAAa;AACjC,cAAM,WAAW,aAAa;AAC9B,cAAM,OAAO,aAAa,IAAI;AAE9B,cAAM,WAAW,aAAa,QAAQ;AACtC,YAAI,gBAAgB,cAAc,IAAI,GAAG;AACrC,iBAAO;AAAA,QACX;AACA,YAAI,QAAQ,CAAC,aAAa;AACtB,yBAAe,CAAC;AAChB,cAAI,CAAC,gBAAgB,EAAE,YAAY,WAAW;AAC1C,mBAAO;AAAA,UACX;AAAA,QACJ;AACA,YAAI,CAAC,kBAAkB;AACnB,iBAAO,SAAS;AAAA,QAEpB;AACA,eAAO;AAAA,MACX;AACA,YAAM,QAAQ,SAAS,UAAU,cAAc;AAC/C,eAAS,KAAK;AACd,gBAAU,iBAAiB,IAAI,KAAK,CAAC;AACrC,UAAI,SAAS,OAAO,GAAG;AACnB,eAAO;AAAA,MACX;AACA,aAAO;AAAA,IACX;AACA,UAAM,YAAY,CAAC,SAAO,EAAE,SAAS,MAAM,aAAa,IAAI,KAAK,SAAS,OAAO;AACjF,UAAM,QAAQ,SAAS,UAAU,SAAS;AAC1C,cAAU,UAAU,KAAK;AACzB,yBAAqB,KAAK;AAC1B,aAAS,KAAK;AAEd,QAAI,kBAAkB;AAClB,aAAO;AAAA,IACX;AACA,UAAM,QAAQ,SAAS,SAAS,EAAE;AAClC,WAAO,QAAQ,iBAAiB;AAAA,EACpC;AACA,WAAS,WAAW;AAChB,UAAM,WAAW,MAAM,QAAQ;AAC/B,UAAM,WAAW,MAAM,QAAQ;AAC/B,UAAM,KAAK;AAEX,UAAM,SAAS,MAAM,gBAAgB,QAAQ;AAC7C,UAAM,kBAAkB,OAAO,WAAW,KAAK,OAAO,QAAQ,OAAO,KAAK;AAC1E,QAAI,eAAe,QAAQ,KAAK,mBAAmB,MAAM,OAAO,GAAG;AAC/D,gBAAU,WAAW,QAAQ;AAC7B,aAAO;AAAA,IACX;AAEA,UAAM,iBAAiB,OAAO,QAAQ,EAAE,MAAM;AAE9C,UAAM,eAAe,OAAO,CAAC,MAAM;AACnC,QAAI,kBAAkB,cAAc;AAChC,YAAM,OAAO,MAAM,UAAU,CAAC,SAAO,SAAS,QAAQ;AACtD,YAAM,KAAK;AACX,gBAAU,UAAU,IAAI;AACxB,2BAAqB,MAAM,YAAY;AACvC,aAAO;AAAA,IACX;AACA,WAAO;AAAA,EACX;AACA,WAAS,aAAa;AAClB,UAAM,SAAS;AACf,UAAM,SAAS,MAAM,UAAU,CAAC,SAAO,SAAS,UAAU,MAAM;AAChE,UAAM,aAAa,kBAAkB,QAAQ;AAAA,MACzC;AAAA,IACJ,CAAC;AACD,UAAM,WAAW,WAAW,SAAS,KAAK;AAC1C,cAAU;AACV,WAAM,WAAW,QAAQ,GAAE;AACvB,gBAAU,aAAa,YAAY,CAAC,QAAQ;AAAA,IAChD;AACA,UAAM,KAAK;AACX,WAAO;AAAA,EACX;AACA,WAAS,YAAY;AACjB,QAAI,UAAU,MAAM,QAAQ,CAAC,GAAG;AAC5B,gBAAU,eAAe,MAAM,QAAQ,CAAC;AACxC,YAAM,KAAK;AACX,YAAM;AACN;AACA,aAAO;AAAA,IACX;AACA,QAAI,aAAa,MAAM,QAAQ,CAAC,GAAG;AAC/B,YAAM,OAAO,MAAM,UAAU,YAAY;AACzC,gBAAU,YAAY,IAAI;AAC1B,aAAO;AAAA,IACX;AACA,QAAI,MAAM,QAAQ,MAAM,SAAS;AAC7B,UAAI,gBAAgB;AAChB,cAAM,aAAa,QAAQ,SAAS,MAAM,SAAS,eAAe;AAClE,cAAM,cAAc,GAAG,UAAU,QAAQ;AACzC,cAAM,WAAW,MAAM,MAAM,UAAU;AACvC,cAAM,uBAAuB,aAAa;AAC1C,YAAI,sBAAsB;AACtB,iBAAO;AAAA,QACX;AAAA,MACJ,WAAW,MAAM,SAAS,QAAQ,GAAG;AACjC,eAAO;AAAA,MACX;AACA,gBAAU,WAAW,MAAM,QAAQ,CAAC;AACpC,YAAM,KAAK;AACX,aAAO;AAAA,IACX;AACA,QAAI,YAAY;AACZ,UAAI,aAAa,MAAM,QAAQ,CAAC,GAAG;AAC/B,cAAM,WAAW,MAAM,QAAQ;AAC/B,cAAM,WAAW,MAAM,QAAQ;AAC/B,cAAM,KAAK;AACX,YAAI,gBAAgB,QAAQ,GAAG;AAC3B,gBAAM,KAAK;AACX,oBAAU,WAAW,QAAQ;AAC7B,iBAAO;AAAA,QACX;AACA,kBAAU,WAAW,QAAQ;AAC7B,eAAO;AAAA,MACX;AACA,YAAM,SAAS,CAAC,SAAO,YAAY,IAAI,KAAK,CAAC,aAAa,IAAI;AAC9D,YAAM,QAAQ,MAAM,UAAU,MAAM;AACpC,gBAAU,WAAW,KAAK;AAC1B,aAAO;AAAA,IACX;AACA,UAAM,QAAQ,MAAM,UAAU,WAAW;AACzC,cAAU,WAAW,KAAK;AAC1B,WAAO;AAAA,EACX;AACA,WAAS,WAAW;AAChB,gBAAY;AACZ,WAAM,MAAM,QAAQ,GAAE;AAClB,cAAO,WAAU;AAAA,QACb,KAAK;AACD,sBAAY,SAAS;AACrB;AAAA,QACJ,KAAK;AACD,sBAAY,WAAW;AACvB;AAAA,QACJ,KAAK;AAAA,QACL;AACI,sBAAY,UAAU;AACtB;AAAA,MACR;AAAA,IACJ;AACA,WAAO,SAAS,aAAa;AAC7B,WAAO;AAAA,EACX;AACA,WAAS,cAAc,OAAO;AAC1B,UAAM,QAAQ,UAAU,QAAQ,MAAM,SAAS;AAE/C,WAAO,OAAO,QAAQ,KAAK,IAAI;AAAA,EACnC;AACA,SAAO;AAAA,IACH;AAAA,IACA;AAAA,EACJ;AACJ;;;AC/QI,IAAM,QAAQ,CAAC,OAAO,OAAO,CAAC,MAAI;AAClC,QAAM,UAAU;AAChB,QAAM,UAAU,QAAQ,WAAW;AACnC,QAAM,WAAW,QAAQ,YAAY;AACrC,MAAI,YAAY;AAKd,QAAM,QAAQ,WAAW;AAKzB,QAAM,cAAc,WAAW;AAK/B,QAAM,WAAW,WAAW;AAK5B,QAAM,mBAAmB,WAAW;AAGpC,QAAM,gBAAgB,oBAAI,IAAI;AAK9B,QAAM,gBAAgB,CAAC,UAAQ;AAC7B,UAAM,QAAQ,MAAM,SAAS;AAC7B,QAAI,CAAC,cAAc,IAAI,KAAK,KAAK,UAAU,iBAAiB,UAAU,cAAc,KAAK,GAAG;AACxF,oBAAc,IAAI,KAAK;AACvB,aAAO;AAAA,IACX;AACA,WAAO,cAAc,IAAI,KAAK;AAAA,EAClC;AAIE,QAAM,cAAc,CAAC,YAAU,QAAQ,cAAc,IAAI,OAAO,CAAC;AAKjE,QAAM,eAAe,CAAC,UAAQ;AAC5B,QAAI,QAAQ,iBAAiB,QAAQ,cAAc,QAAQ;AACvD,aAAO,QAAQ,cAAc,QAAQ,KAAK,KAAK;AAAA,IACnD;AACA,WAAO;AAAA,EACX;AAKE,QAAM,gBAAgB,MAAI;AACxB,QAAI,SAAS,UAAU,GAAG;AACtB,uBAAiB,UAAU;AAAA,IAC/B;AAAA,EACJ;AAIE,QAAM,WAAW,MAAI;AACnB,UAAM,iBAAiB,YAAY,QAAQ;AAC3C,QAAI,kBAAkB,MAAM,QAAQ,eAAe,OAAO,GAAG;AACzD,aAAO,eAAe;AAAA,IAC1B;AACA,WAAO,MAAM,QAAQ;AAAA,EACzB;AAIE,QAAM,cAAc,CAAC,SAAO;AAC1B,UAAM,QAAQ,SAAS;AACvB,QAAI,MAAM,QAAQ,KAAK,GAAG;AACtB,UAAI,UAAU,IAAI,GAAG;AACjB,YAAI,aAAa,KAAK,GAAG,GAAG;AACxB,gBAAM,KAAK,KAAK,UAAU,CAAC;AAAA,QAC/B,OAAO;AACH,gBAAM,KAAK,KAAK,WAAW;AAAA,YACvB;AAAA,YACA;AAAA,UACJ,CAAC,CAAC;AACF,cAAI,KAAK,QAAQ,QAAQ;AACrB,iBAAK,QAAQ,QAAQ,CAAC,SAAO;AACzB,oBAAM,KAAK,IAAI;AAAA,YACnB,CAAC;AACD,kBAAM,KAAK,KAAK,SAAS;AAAA,cACrB;AAAA,cACA;AAAA,YACJ,CAAC,CAAC;AAAA,UACN;AAAA,QACJ;AAAA,MACJ,OAAO;AACH,cAAM,KAAK,IAAI;AAAA,MACnB;AAAA,IACJ;AAAA,EACJ;AAIE,QAAM,iBAAiB,CAAC,UAAQ;AAC9B,kBAAc;AACd,UAAM,UAAU,QAAQ,OAAO,MAAM,SAAS,CAAC;AAC/C,UAAM,WAAW,cAAc,KAAK;AACpC,aAAS,KAAK,OAAO;AACrB,QAAI,UAAU;AACV,kBAAY,KAAK,OAAO;AAAA,IAC5B,OAAO;AACH,kBAAY,SAAS,KAAK;AAAA,IAC9B;AAAA,EACJ;AAIE,QAAM,eAAe,CAAC,UAAQ;AAC5B,kBAAc;AACd,UAAM,iBAAiB,YAAY,UAAU;AAC7C,QAAI,gBAAgB;AAChB,kBAAY,gBAAgB,KAAK;AAAA,IACrC,WAAW,OAAO,QAAQ,YAAY,YAAY;AAC9C,YAAM,MAAM,MAAM,SAAS;AAC3B,YAAM,OAAO,MAAM,QAAQ;AAC3B,YAAM,SAAS,MAAM,UAAU;AAC/B,cAAQ,QAAQ;AAAA,QACZ,SAAS,qBAAqB,gBAAgB,mBAAmB;AAAA,QACjE,SAAS;AAAA,QACT,YAAY;AAAA,QACZ,cAAc;AAAA,MAClB,CAAC;AAAA,IACL;AAAA,EACJ;AAIE,QAAM,YAAY,CAAC,UAAQ;AAEzB,QAAI,MAAM,QAAQ,GAAG;AACjB,qBAAe,KAAK;AAAA,IACxB;AAEA,QAAI,MAAM,MAAM,GAAG;AACf,mBAAa,KAAK;AAAA,IACtB;AAAA,EACJ;AAIE,QAAM,aAAa,CAAC,UAAQ;AAG1B,UAAM,cAAc,SAAS,QAAQ;AACrC,UAAM,aAAa,MAAM,SAAS;AAClC,UAAM,WAAW,YAAY,KAAK;AAClC,QAAI,aAAa;AACb,UAAI,MAAM,WAAW,GAAG;AACpB,yBAAiB,KAAK,UAAU;AAChC,oBAAY,KAAK,iBAAiB,QAAQ,GAAG,EAAE;AAAA,MACnD,WAAW,MAAM,YAAY,GAAG;AAC5B,cAAM,WAAW,iBAAiB,QAAQ;AAC1C,YAAI,UAAU;AACV,sBAAY,KAAK,UAAU,UAAU;AACrC,2BAAiB,UAAU;AAAA,QAC/B,OAAO;AACH,sBAAY,KAAK,YAAY,UAAU;AAAA,QAC3C;AAAA,MACJ,WAAW,MAAM,OAAO,GAAG;AACvB,YAAI,UAAU;AACV,sBAAY,OAAO,UAAU;AAAA,QACjC,OAAO;AACH,sBAAY,UAAU;AAAA,QAC1B;AAAA,MACJ,WAAW,MAAM,MAAM,GAAG;AAEtB,oBAAY,MAAM,SAAS,CAAC;AAAA,MAChC;AAAA,IACJ,WAAW,MAAM,OAAO,GAAG;AACvB,kBAAY,UAAU;AAAA,IAC1B,WAAW,MAAM,MAAM,GAAG;AAEtB,kBAAY,MAAM,SAAS,CAAC;AAAA,IAChC;AAAA,EACJ;AAIE,QAAM,UAAU,CAAC,UAAQ;AACvB,QAAI,MAAM,MAAM,GAAG;AACf,gBAAU,KAAK;AAAA,IACnB,OAAO;AACH,iBAAW,KAAK;AAAA,IACpB;AAAA,EACJ;AACA,eAAa,KAAK,kBAAkB,KAAK,kBAAkB,aAAa,OAAO;AAAA,IAC3E;AAAA,IACA;AAAA,IACA;AAAA,IACA,eAAe,QAAQ;AAAA,IACvB,iBAAiB,QAAQ;AAAA,IACzB,kBAAkB,QAAQ;AAAA,EAC9B,CAAC;AAED,QAAM,SAAS,UAAU,SAAS;AAClC,SAAO,MAAM,QAAQ;AACzB;;;AC9NiC,IAAM,QAAQ,CAAC,UAAQ,OAAO,UAAU;AACzE,IAAM,SAAS,CAAC,UAAQ,OAAO,UAAU;AAClC,SAAS,QAAQ,GAAG,IAAI;AAC3B,QAAM,OAAO;AACb,MAAI,MAAM,QAAQ,IAAI,GAAG;AACrB,aAAQ,MAAM,GAAG,MAAM,KAAK,QAAQ,OAAM;AACtC,WAAK,GAAG,IAAI,QAAQ,GAAG,KAAK,GAAG,CAAC,GAAG,EAAE;AAAA,IACzC;AAAA,EACJ,WAAW,QAAQ,MAAM,IAAI,KAAK,KAAK,SAAS;AAC5C,YAAQ,KAAK,SAAS,EAAE;AAAA,EAC5B;AACA,SAAO;AACX;AACO,SAAS,KAAK,UAAU,QAAQ;AACnC,MAAI,OAAO,aAAa,OAAO,QAAQ;AACnC,WAAO;AAAA,EACX;AACA,MAAI,CAAC,MAAM,QAAQ,KAAK,aAAa,MAAM;AACvC,WAAO,aAAa;AAAA,EACxB;AACA,MAAI,MAAM,QAAQ,QAAQ,GAAG;AACzB,WAAO,SAAS,MAAM,CAAC,QAAM,CAAC,EAAE,KAAK,KAAK,QAAQ,CAAC,QAAM,KAAK,KAAK,GAAG,CAAC,CAAC;AAAA,EAC5E;AACA,SAAO,OAAO,KAAK,QAAQ,EAAE,MAAM,CAAC,QAAM;AACtC,UAAM,KAAK,OAAO,GAAG;AACrB,UAAM,KAAK,SAAS,GAAG;AACvB,QAAI,MAAM,EAAE,KAAK,OAAO,QAAQ,OAAO,MAAM;AACzC,aAAO,KAAK,IAAI,EAAE;AAAA,IACtB;AACA,QAAI,OAAO,EAAE,GAAG;AACZ,aAAO,QAAQ,OAAO;AAAA,IAC1B;AACA,WAAO,OAAO;AAAA,EAClB,CAAC;AACL;AACO,SAAS,MAAM,YAAY,IAAI;AAClC,SAAO,MAAM,QAAQ,UAAU,IAAI,QAAQ,MAAM,CAAC,SAAO;AACrD,aAAQ,MAAM,GAAG,MAAM,WAAW,QAAQ,OAAM;AAC5C,UAAI,KAAK,WAAW,GAAG,GAAG,IAAI,GAAG;AAC7B,eAAO,GAAG,IAAI;AAAA,MAClB;AAAA,IACJ;AACA,WAAO;AAAA,EACX,CAAC,IAAI,QAAQ,MAAM,CAAC,SAAO,KAAK,YAAY,IAAI,IAAI,GAAG,IAAI,IAAI,IAAI;AACvE;;;AC1CA,SAAS,KAAK,IAAI;AACd,SAAO,QAAQ,MAAM,EAAE;AAC3B;AACe,SAAR,KAAsB,OAAO;AAChC,QAAM,UAAU,OAAO,UAAU,aAAa;AAAA,IAC1C;AAAA,EACJ,IAAI,SAAS,CAAC;AACd,MAAI,UAAU;AAAA,IACV,WAAW;AAAA,EACf;AACA,SAAO;AAAA,IACH,QAAS,OAAO,MAAM;AAClB,gBAAU,QAAQ,CAAC;AACnB,YAAM,UAAU,QAAQ,UAAU;AAClC,YAAM,WAAW,QAAQ;AACzB,YAAM,OAAO,QAAQ,QAAQ;AAC7B,UAAI,OAAO,YAAY,YAAY;AAC/B,cAAM,IAAI,MAAM,wFAAwF;AAAA,MAC5G;AACA,UAAI,OAAO,QAAQ,YAAY,SAAS,CAAC,IAAI,QAAQ,OAAO,OAAO;AAEnE,YAAM,MAAM;AACZ,WAAK,WAAW,CAAC;AACjB,WAAK,UAAU;AACf,WAAK,OAAO;AACZ,WAAK,QAAQ;AACb,cAAQ,QAAQ,CAAC,WAAS;AACtB,eAAO,OAAO,MAAM;AAAA,UAChB,OAAO;AAAA,UACP,QAAQ;AAAA,UACR;AAAA,UACA;AAAA,UACA;AAAA,QACJ,CAAC,KAAK;AAAA,MACV,CAAC;AACD,aAAO;AAAA,QACH,IAAI,OAAQ;AACR,cAAI,OAAO,aAAa,YAAY;AAChC,kBAAM,IAAI,MAAM,4EAA4E;AAAA,UAChG;AACA,iBAAO,SAAS,MAAM,KAAK,OAAO;AAAA,QACtC;AAAA,QACA;AAAA,QACA;AAAA,QACA,UAAU,KAAK;AAAA,MACnB;AAAA,IACJ;AAAA,EACJ;AACJ;;;AChDA,IAAM,oBAAoB;AAC1B,IAAM,kBAAkB;AACxB,IAAM,YAAY;AAClB,IAAM,UAAU;AAChB,IAAM,aAAa,CAAC,MAAM,EAAE,YAAW,MAAO,MAAI;AAC9C,MAAI,CAAC;AAAM,WAAO;AAClB,QAAM,OAAO,OAAO;AACpB,MAAI,SAAS,YAAY,SAAS,UAAU;AACxC,WAAO;AAAA,EACX;AACA,MAAI,SAAS,UAAU;AACnB,QAAI,cAAc,MAAM;AAEpB,aAAO,YAAY,KAAK,SAAS;AAAA,QAC7B;AAAA,MACJ,CAAC;AAAA,IACL;AACA,QAAI,KAAK,YAAY,MAAM;AACvB,aAAO;AAAA,QACH;AAAA,QACA,KAAK;AAAA,QACL,cAAc,KAAK,KAAK;AAAA,QACxB;AAAA,MACJ,EAAE,KAAK,EAAE;AAAA,IACb;AAEA,WAAO;AAAA,MACH;AAAA,MACA,KAAK;AAAA,MACL,cAAc,KAAK,KAAK;AAAA,MACxB;AAAA,MACA,YAAY,KAAK,OAAO;AAAA,MACxB;AAAA,MACA,KAAK;AAAA,MACL;AAAA,IACJ,EAAE,KAAK,EAAE;AAAA,EACb;AACA,MAAI,MAAM,QAAQ,IAAI,GAAG;AAErB,WAAO,YAAY,MAAM;AAAA,MACrB;AAAA,IACJ,CAAC;AAAA,EACL;AACA,SAAO;AACX;AACA,IAAM,cAAc,CAAC,OAAO,EAAE,YAAW,MAAO,IAAI,CAAC,MAAI,CAAC,EAAE,OAAO,KAAK,EAAE,OAAO,CAAC,GAAG,SAAO,IAAI,WAAW,MAAM;AAAA,EACrG;AACJ,CAAC,GAAG,EAAE;AACd,IAAM,SAAS,CAAC,QAAQ,SAAS,YAAU,KAAK,OAAO,EAAE,QAAQ,QAAQ;AAAA,EACjE,GAAG;AAAA,EACH,QAAQ;AACZ,CAAC,EAAE;AACA,IAAM,SAAS;AACtB,IAAO,aAAQ;",
  "names": []
}
