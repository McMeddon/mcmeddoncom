import {
  BACKSLASH,
  CLOSE_BRAKET,
  EQ,
  N,
  OPEN_BRAKET,
  QUOTEMARK,
  SLASH,
  SPACE,
  TAB,
  TagNode,
  attrsToString,
  isTagNode
} from "./chunk-BHFTSBAC.js";

// node_modules/@bbob/parser/es/Token.js
var TOKEN_TYPE_ID = "type";
var TOKEN_VALUE_ID = "value";
var TOKEN_COLUMN_ID = "row";
var TOKEN_LINE_ID = "line";
var TOKEN_TYPE_WORD = 1;
var TOKEN_TYPE_TAG = 2;
var TOKEN_TYPE_ATTR_NAME = 3;
var TOKEN_TYPE_ATTR_VALUE = 4;
var TOKEN_TYPE_SPACE = 5;
var TOKEN_TYPE_NEW_LINE = 6;
var getTokenValue = (token) => {
  if (token && typeof token[TOKEN_VALUE_ID] !== "undefined") {
    return token[TOKEN_VALUE_ID];
  }
  return "";
};
var getTokenLine = (token) => token && token[TOKEN_LINE_ID] || 0;
var getTokenColumn = (token) => token && token[TOKEN_COLUMN_ID] || 0;
var isTextToken = (token) => {
  if (token && typeof token[TOKEN_TYPE_ID] !== "undefined") {
    return token[TOKEN_TYPE_ID] === TOKEN_TYPE_SPACE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_NEW_LINE || token[TOKEN_TYPE_ID] === TOKEN_TYPE_WORD;
  }
  return false;
};
var isTagToken = (token) => {
  if (token && typeof token[TOKEN_TYPE_ID] !== "undefined") {
    return token[TOKEN_TYPE_ID] === TOKEN_TYPE_TAG;
  }
  return false;
};
var isTagEnd = (token) => getTokenValue(token).charCodeAt(0) === SLASH.charCodeAt(0);
var isTagStart = (token) => !isTagEnd(token);
var isAttrNameToken = (token) => {
  if (token && typeof token[TOKEN_TYPE_ID] !== "undefined") {
    return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_NAME;
  }
  return false;
};
var isAttrValueToken = (token) => {
  if (token && typeof token[TOKEN_TYPE_ID] !== "undefined") {
    return token[TOKEN_TYPE_ID] === TOKEN_TYPE_ATTR_VALUE;
  }
  return false;
};
var getTagName = (token) => {
  const value = getTokenValue(token);
  return isTagEnd(token) ? value.slice(1) : value;
};
var convertTagToText = (token) => {
  let text = OPEN_BRAKET;
  text += getTokenValue(token);
  text += CLOSE_BRAKET;
  return text;
};
var Token = class {
  isEmpty() {
    return isNaN(this[TOKEN_TYPE_ID]);
  }
  isText() {
    return isTextToken(this);
  }
  isTag() {
    return isTagToken(this);
  }
  isAttrName() {
    return isAttrNameToken(this);
  }
  isAttrValue() {
    return isAttrValueToken(this);
  }
  isStart() {
    return isTagStart(this);
  }
  isEnd() {
    return isTagEnd(this);
  }
  getName() {
    return getTagName(this);
  }
  getValue() {
    return getTokenValue(this);
  }
  getLine() {
    return getTokenLine(this);
  }
  getColumn() {
    return getTokenColumn(this);
  }
  toString() {
    return convertTagToText(this);
  }
  /**
  * @param {String} type
  * @param {String} value
  * @param line
  * @param row
  */
  constructor(type, value, line, row) {
    this[TOKEN_TYPE_ID] = Number(type);
    this[TOKEN_VALUE_ID] = String(value);
    this[TOKEN_LINE_ID] = Number(line);
    this[TOKEN_COLUMN_ID] = Number(row);
  }
};
var TYPE_WORD = TOKEN_TYPE_WORD;
var TYPE_TAG = TOKEN_TYPE_TAG;
var TYPE_ATTR_NAME = TOKEN_TYPE_ATTR_NAME;
var TYPE_ATTR_VALUE = TOKEN_TYPE_ATTR_VALUE;
var TYPE_SPACE = TOKEN_TYPE_SPACE;
var TYPE_NEW_LINE = TOKEN_TYPE_NEW_LINE;

// node_modules/@bbob/parser/es/utils.js
function CharGrabber(source, options) {
  const cursor = {
    pos: 0,
    len: source.length
  };
  const substrUntilChar = (char) => {
    const { pos } = cursor;
    const idx = source.indexOf(char, pos);
    return idx >= 0 ? source.substring(pos, idx) : "";
  };
  const includes = (val) => source.indexOf(val, cursor.pos) >= 0;
  const hasNext = () => cursor.len > cursor.pos;
  const isLast = () => cursor.pos === cursor.len;
  const skip = (num = 1, silent) => {
    cursor.pos += num;
    if (options && options.onSkip && !silent) {
      options.onSkip();
    }
  };
  const rest = () => source.substring(cursor.pos);
  const grabN = (num = 0) => source.substring(cursor.pos, cursor.pos + num);
  const curr = () => source[cursor.pos];
  const prev = () => {
    const prevPos = cursor.pos - 1;
    return typeof source[prevPos] !== "undefined" ? source[prevPos] : null;
  };
  const next = () => {
    const nextPos = cursor.pos + 1;
    return nextPos <= source.length - 1 ? source[nextPos] : null;
  };
  const grabWhile = (cond, silent) => {
    let start = 0;
    if (hasNext()) {
      start = cursor.pos;
      while (hasNext() && cond(curr())) {
        skip(1, silent);
      }
    }
    return source.substring(start, cursor.pos);
  };
  this.skip = skip;
  this.hasNext = hasNext;
  this.getCurr = curr;
  this.getRest = rest;
  this.getNext = next;
  this.getPrev = prev;
  this.isLast = isLast;
  this.includes = includes;
  this.grabWhile = grabWhile;
  this.grabN = grabN;
  this.substrUntilChar = substrUntilChar;
}
var createCharGrabber = (source, options) => new CharGrabber(source, options);
var trimChar = (str, charToRemove) => {
  while (str.charAt(0) === charToRemove) {
    str = str.substring(1);
  }
  while (str.charAt(str.length - 1) === charToRemove) {
    str = str.substring(0, str.length - 1);
  }
  return str;
};
var unquote = (str) => str.replace(BACKSLASH + QUOTEMARK, QUOTEMARK);
function NodeList(values = []) {
  const nodes = values;
  const getLast = () => Array.isArray(nodes) && nodes.length > 0 && typeof nodes[nodes.length - 1] !== "undefined" ? nodes[nodes.length - 1] : null;
  const flushLast = () => nodes.length ? nodes.pop() : false;
  const push = (value) => nodes.push(value);
  const toArray = () => nodes;
  this.push = push;
  this.toArray = toArray;
  this.getLast = getLast;
  this.flushLast = flushLast;
}
var createList = (values = []) => new NodeList(values);

// node_modules/@bbob/parser/es/lexer.js
var EM = "!";
var createToken = (type, value, r = 0, cl = 0) => new Token(type, value, r, cl);
function createLexer(buffer, options = {}) {
  const STATE_WORD = 0;
  const STATE_TAG = 1;
  const STATE_TAG_ATTRS = 2;
  const TAG_STATE_NAME = 0;
  const TAG_STATE_ATTR = 1;
  const TAG_STATE_VALUE = 2;
  let row = 0;
  let col = 0;
  let tokenIndex = -1;
  let stateMode = STATE_WORD;
  let tagMode = TAG_STATE_NAME;
  let contextFreeTag = "";
  const tokens = new Array(Math.floor(buffer.length));
  const openTag = options.openTag || OPEN_BRAKET;
  const closeTag = options.closeTag || CLOSE_BRAKET;
  const escapeTags = !!options.enableEscapeTags;
  const contextFreeTags = options.contextFreeTags || [];
  const onToken = options.onToken || (() => {
  });
  const RESERVED_CHARS = [
    closeTag,
    openTag,
    QUOTEMARK,
    BACKSLASH,
    SPACE,
    TAB,
    EQ,
    N,
    EM
  ];
  const NOT_CHAR_TOKENS = [
    openTag,
    SPACE,
    TAB,
    N
  ];
  const WHITESPACES = [
    SPACE,
    TAB
  ];
  const SPECIAL_CHARS = [
    EQ,
    SPACE,
    TAB
  ];
  const isCharReserved = (char) => RESERVED_CHARS.indexOf(char) >= 0;
  const isNewLine = (char) => char === N;
  const isWhiteSpace = (char) => WHITESPACES.indexOf(char) >= 0;
  const isCharToken = (char) => NOT_CHAR_TOKENS.indexOf(char) === -1;
  const isSpecialChar = (char) => SPECIAL_CHARS.indexOf(char) >= 0;
  const isEscapableChar = (char) => char === openTag || char === closeTag || char === BACKSLASH;
  const isEscapeChar = (char) => char === BACKSLASH;
  const onSkip = () => {
    col++;
  };
  const unq = (val) => unquote(trimChar(val, QUOTEMARK));
  const checkContextFreeMode = (name, isClosingTag) => {
    if (contextFreeTag !== "" && isClosingTag) {
      contextFreeTag = "";
    }
    if (contextFreeTag === "" && contextFreeTags.includes(name)) {
      contextFreeTag = name;
    }
  };
  const chars = createCharGrabber(buffer, {
    onSkip
  });
  function emitToken(type, value) {
    const token = createToken(type, value, row, col);
    onToken(token);
    tokenIndex += 1;
    tokens[tokenIndex] = token;
  }
  function nextTagState(tagChars, isSingleValueTag) {
    if (tagMode === TAG_STATE_ATTR) {
      const validAttrName = (char) => !(char === EQ || isWhiteSpace(char));
      const name = tagChars.grabWhile(validAttrName);
      const isEnd = tagChars.isLast();
      const isValue = tagChars.getCurr() !== EQ;
      tagChars.skip();
      if (isEnd || isValue) {
        emitToken(TYPE_ATTR_VALUE, unq(name));
      } else {
        emitToken(TYPE_ATTR_NAME, name);
      }
      if (isEnd) {
        return TAG_STATE_NAME;
      }
      if (isValue) {
        return TAG_STATE_ATTR;
      }
      return TAG_STATE_VALUE;
    }
    if (tagMode === TAG_STATE_VALUE) {
      let stateSpecial = false;
      const validAttrValue = (char) => {
        const isQM = char === QUOTEMARK;
        const prevChar = tagChars.getPrev();
        const nextChar = tagChars.getNext();
        const isPrevSLASH = prevChar === BACKSLASH;
        const isNextEQ = nextChar === EQ;
        const isWS = isWhiteSpace(char);
        const isNextWS = isWhiteSpace(nextChar);
        if (stateSpecial && isSpecialChar(char)) {
          return true;
        }
        if (isQM && !isPrevSLASH) {
          stateSpecial = !stateSpecial;
          if (!stateSpecial && !(isNextEQ || isNextWS)) {
            return false;
          }
        }
        if (!isSingleValueTag) {
          return isWS === false;
        }
        return true;
      };
      const name1 = tagChars.grabWhile(validAttrValue);
      tagChars.skip();
      emitToken(TYPE_ATTR_VALUE, unq(name1));
      if (tagChars.isLast()) {
        return TAG_STATE_NAME;
      }
      return TAG_STATE_ATTR;
    }
    const validName = (char) => !(char === EQ || isWhiteSpace(char) || tagChars.isLast());
    const name2 = tagChars.grabWhile(validName);
    emitToken(TYPE_TAG, name2);
    checkContextFreeMode(name2);
    tagChars.skip();
    if (isSingleValueTag) {
      return TAG_STATE_VALUE;
    }
    const hasEQ = tagChars.includes(EQ);
    return hasEQ ? TAG_STATE_ATTR : TAG_STATE_VALUE;
  }
  function stateTag() {
    const currChar = chars.getCurr();
    const nextChar = chars.getNext();
    chars.skip();
    const substr = chars.substrUntilChar(closeTag);
    const hasInvalidChars = substr.length === 0 || substr.indexOf(openTag) >= 0;
    if (isCharReserved(nextChar) || hasInvalidChars || chars.isLast()) {
      emitToken(TYPE_WORD, currChar);
      return STATE_WORD;
    }
    const isNoAttrsInTag = substr.indexOf(EQ) === -1;
    const isClosingTag = substr[0] === SLASH;
    if (isNoAttrsInTag || isClosingTag) {
      const name = chars.grabWhile((char) => char !== closeTag);
      chars.skip();
      emitToken(TYPE_TAG, name);
      checkContextFreeMode(name, isClosingTag);
      return STATE_WORD;
    }
    return STATE_TAG_ATTRS;
  }
  function stateAttrs() {
    const silent = true;
    const tagStr = chars.grabWhile((char) => char !== closeTag, silent);
    const tagGrabber = createCharGrabber(tagStr, {
      onSkip
    });
    const hasSpace = tagGrabber.includes(SPACE);
    tagMode = TAG_STATE_NAME;
    while (tagGrabber.hasNext()) {
      tagMode = nextTagState(tagGrabber, !hasSpace);
    }
    chars.skip();
    return STATE_WORD;
  }
  function stateWord() {
    if (isNewLine(chars.getCurr())) {
      emitToken(TYPE_NEW_LINE, chars.getCurr());
      chars.skip();
      col = 0;
      row++;
      return STATE_WORD;
    }
    if (isWhiteSpace(chars.getCurr())) {
      const word = chars.grabWhile(isWhiteSpace);
      emitToken(TYPE_SPACE, word);
      return STATE_WORD;
    }
    if (chars.getCurr() === openTag) {
      if (contextFreeTag) {
        const fullTagLen = openTag.length + SLASH.length + contextFreeTag.length;
        const fullTagName = `${openTag}${SLASH}${contextFreeTag}`;
        const foundTag = chars.grabN(fullTagLen);
        const isEndContextFreeMode = foundTag === fullTagName;
        if (isEndContextFreeMode) {
          return STATE_TAG;
        }
      } else if (chars.includes(closeTag)) {
        return STATE_TAG;
      }
      emitToken(TYPE_WORD, chars.getCurr());
      chars.skip();
      return STATE_WORD;
    }
    if (escapeTags) {
      if (isEscapeChar(chars.getCurr())) {
        const currChar = chars.getCurr();
        const nextChar = chars.getNext();
        chars.skip();
        if (isEscapableChar(nextChar)) {
          chars.skip();
          emitToken(TYPE_WORD, nextChar);
          return STATE_WORD;
        }
        emitToken(TYPE_WORD, currChar);
        return STATE_WORD;
      }
      const isChar = (char) => isCharToken(char) && !isEscapeChar(char);
      const word1 = chars.grabWhile(isChar);
      emitToken(TYPE_WORD, word1);
      return STATE_WORD;
    }
    const word2 = chars.grabWhile(isCharToken);
    emitToken(TYPE_WORD, word2);
    return STATE_WORD;
  }
  function tokenize() {
    stateMode = STATE_WORD;
    while (chars.hasNext()) {
      switch (stateMode) {
        case STATE_TAG:
          stateMode = stateTag();
          break;
        case STATE_TAG_ATTRS:
          stateMode = stateAttrs();
          break;
        case STATE_WORD:
        default:
          stateMode = stateWord();
          break;
      }
    }
    tokens.length = tokenIndex + 1;
    return tokens;
  }
  function isTokenNested(token) {
    const value = openTag + SLASH + token.getValue();
    return buffer.indexOf(value) > -1;
  }
  return {
    tokenize,
    isTokenNested
  };
}

// node_modules/@bbob/parser/es/parse.js
var parse = (input, opts = {}) => {
  const options = opts;
  const openTag = options.openTag || OPEN_BRAKET;
  const closeTag = options.closeTag || CLOSE_BRAKET;
  let tokenizer = null;
  const nodes = createList();
  const nestedNodes = createList();
  const tagNodes = createList();
  const tagNodesAttrName = createList();
  const nestedTagsMap = /* @__PURE__ */ new Set();
  const isTokenNested = (token) => {
    const value = token.getValue();
    if (!nestedTagsMap.has(value) && tokenizer.isTokenNested && tokenizer.isTokenNested(token)) {
      nestedTagsMap.add(value);
      return true;
    }
    return nestedTagsMap.has(value);
  };
  const isTagNested = (tagName) => Boolean(nestedTagsMap.has(tagName));
  const isAllowedTag = (value) => {
    if (options.onlyAllowTags && options.onlyAllowTags.length) {
      return options.onlyAllowTags.indexOf(value) >= 0;
    }
    return true;
  };
  const flushTagNodes = () => {
    if (tagNodes.flushLast()) {
      tagNodesAttrName.flushLast();
    }
  };
  const getNodes = () => {
    const lastNestedNode = nestedNodes.getLast();
    if (lastNestedNode && Array.isArray(lastNestedNode.content)) {
      return lastNestedNode.content;
    }
    return nodes.toArray();
  };
  const appendNodes = (node) => {
    const items = getNodes();
    if (Array.isArray(items)) {
      if (isTagNode(node)) {
        if (isAllowedTag(node.tag)) {
          items.push(node.toTagNode());
        } else {
          items.push(node.toTagStart({
            openTag,
            closeTag
          }));
          if (node.content.length) {
            node.content.forEach((item) => {
              items.push(item);
            });
            items.push(node.toTagEnd({
              openTag,
              closeTag
            }));
          }
        }
      } else {
        items.push(node);
      }
    }
  };
  const handleTagStart = (token) => {
    flushTagNodes();
    const tagNode = TagNode.create(token.getValue());
    const isNested = isTokenNested(token);
    tagNodes.push(tagNode);
    if (isNested) {
      nestedNodes.push(tagNode);
    } else {
      appendNodes(tagNode, token);
    }
  };
  const handleTagEnd = (token) => {
    flushTagNodes();
    const lastNestedNode = nestedNodes.flushLast();
    if (lastNestedNode) {
      appendNodes(lastNestedNode, token);
    } else if (typeof options.onError === "function") {
      const tag = token.getValue();
      const line = token.getLine();
      const column = token.getColumn();
      options.onError({
        message: `Inconsistent tag '${tag}' on line ${line} and column ${column}`,
        tagName: tag,
        lineNumber: line,
        columnNumber: column
      });
    }
  };
  const handleTag = (token) => {
    if (token.isStart()) {
      handleTagStart(token);
    }
    if (token.isEnd()) {
      handleTagEnd(token);
    }
  };
  const handleNode = (token) => {
    const lastTagNode = tagNodes.getLast();
    const tokenValue = token.getValue();
    const isNested = isTagNested(token);
    if (lastTagNode) {
      if (token.isAttrName()) {
        tagNodesAttrName.push(tokenValue);
        lastTagNode.attr(tagNodesAttrName.getLast(), "");
      } else if (token.isAttrValue()) {
        const attrName = tagNodesAttrName.getLast();
        if (attrName) {
          lastTagNode.attr(attrName, tokenValue);
          tagNodesAttrName.flushLast();
        } else {
          lastTagNode.attr(tokenValue, tokenValue);
        }
      } else if (token.isText()) {
        if (isNested) {
          lastTagNode.append(tokenValue);
        } else {
          appendNodes(tokenValue);
        }
      } else if (token.isTag()) {
        appendNodes(token.toString());
      }
    } else if (token.isText()) {
      appendNodes(tokenValue);
    } else if (token.isTag()) {
      appendNodes(token.toString());
    }
  };
  const onToken = (token) => {
    if (token.isTag()) {
      handleTag(token);
    } else {
      handleNode(token);
    }
  };
  tokenizer = (opts.createTokenizer ? opts.createTokenizer : createLexer)(input, {
    onToken,
    openTag,
    closeTag,
    onlyAllowTags: options.onlyAllowTags,
    contextFreeTags: options.contextFreeTags,
    enableEscapeTags: options.enableEscapeTags
  });
  const tokens = tokenizer.tokenize();
  return nodes.toArray();
};

// node_modules/@bbob/core/es/utils.js
var isObj = (value) => typeof value === "object";
var isBool = (value) => typeof value === "boolean";
function iterate(t, cb) {
  const tree = t;
  if (Array.isArray(tree)) {
    for (let idx = 0; idx < tree.length; idx++) {
      tree[idx] = iterate(cb(tree[idx]), cb);
    }
  } else if (tree && isObj(tree) && tree.content) {
    iterate(tree.content, cb);
  }
  return tree;
}
function same(expected, actual) {
  if (typeof expected !== typeof actual) {
    return false;
  }
  if (!isObj(expected) || expected === null) {
    return expected === actual;
  }
  if (Array.isArray(expected)) {
    return expected.every((exp) => [].some.call(actual, (act) => same(exp, act)));
  }
  return Object.keys(expected).every((key) => {
    const ao = actual[key];
    const eo = expected[key];
    if (isObj(eo) && eo !== null && ao !== null) {
      return same(eo, ao);
    }
    if (isBool(eo)) {
      return eo !== (ao === null);
    }
    return ao === eo;
  });
}
function match(expression, cb) {
  return Array.isArray(expression) ? iterate(this, (node) => {
    for (let idx = 0; idx < expression.length; idx++) {
      if (same(expression[idx], node)) {
        return cb(node);
      }
    }
    return node;
  }) : iterate(this, (node) => same(expression, node) ? cb(node) : node);
}

// node_modules/@bbob/core/es/index.js
function walk(cb) {
  return iterate(this, cb);
}
function bbob(plugs) {
  const plugins = typeof plugs === "function" ? [
    plugs
  ] : plugs || [];
  let options = {
    skipParse: false
  };
  return {
    process(input, opts) {
      options = opts || {};
      const parseFn = options.parser || parse;
      const renderFn = options.render;
      const data = options.data || null;
      if (typeof parseFn !== "function") {
        throw new Error('"parser" is not a function, please pass to "process(input, { parser })" right function');
      }
      let tree = options.skipParse ? input || [] : parseFn(input, options);
      const raw = tree;
      tree.messages = [];
      tree.options = options;
      tree.walk = walk;
      tree.match = match;
      plugins.forEach((plugin) => {
        tree = plugin(tree, {
          parse: parseFn,
          render: renderFn,
          iterate,
          match,
          data
        }) || tree;
      });
      return {
        get html() {
          if (typeof renderFn !== "function") {
            throw new Error('"render" function not defined, please pass to "process(input, { render })"');
          }
          return renderFn(tree, tree.options);
        },
        tree,
        raw,
        messages: tree.messages
      };
    }
  };
}

// node_modules/@bbob/html/es/index.js
var SELFCLOSE_END_TAG = "/>";
var CLOSE_START_TAG = "</";
var START_TAG = "<";
var END_TAG = ">";
var renderNode = (node, { stripTags = false }) => {
  if (!node)
    return "";
  const type = typeof node;
  if (type === "string" || type === "number") {
    return node;
  }
  if (type === "object") {
    if (stripTags === true) {
      return renderNodes(node.content, {
        stripTags
      });
    }
    if (node.content === null) {
      return [
        START_TAG,
        node.tag,
        attrsToString(node.attrs),
        SELFCLOSE_END_TAG
      ].join("");
    }
    return [
      START_TAG,
      node.tag,
      attrsToString(node.attrs),
      END_TAG,
      renderNodes(node.content),
      CLOSE_START_TAG,
      node.tag,
      END_TAG
    ].join("");
  }
  if (Array.isArray(node)) {
    return renderNodes(node, {
      stripTags
    });
  }
  return "";
};
var renderNodes = (nodes, { stripTags = false } = {}) => [].concat(nodes).reduce((r, node) => r + renderNode(node, {
  stripTags
}), "");
var toHTML = (source, plugins, options) => bbob(plugins).process(source, {
  ...options,
  render: renderNodes
}).html;
var render = renderNodes;
var es_default = toHTML;
export {
  es_default as default,
  render
};
//# sourceMappingURL=@bbob_html.js.map
